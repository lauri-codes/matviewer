var matviewer =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/brillouinzoneviewer.js":
/*!***************************************!*\
  !*** ./src/js/brillouinzoneviewer.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BrillouinZoneViewer; });\n/* harmony import */ var _viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer */ \"./src/js/viewer.js\");\n\n/*\n * A 3D visualizer for the Brillouin Zone and the k-point path within it.\n */\nclass BrillouinZoneViewer extends _viewer__WEBPACK_IMPORTED_MODULE_0__[\"Viewer\"] {\n    /*\n     * Overrides the implementation from the base class, as we need two scenes:\n     * one for the BZ mesh and another for the information that is laid on top.\n     */\n    setupScenes() {\n        this.scenes = [];\n        this.sceneZone = new THREE.Scene();\n        this.scenes.push(this.sceneZone);\n        this.sceneInfo = new THREE.Scene();\n        this.scenes.push(this.sceneInfo);\n        //this.setupControlVariables(10, 2.5, 50);\n    }\n    setupLights() {\n        // White directional light shining from the top.\n        let directionalLight = new THREE.DirectionalLight(0xffffff, 0.05);\n        directionalLight.position.set(0, 0, 30);\n        this.sceneZone.add(directionalLight);\n        // White ambient light.\n        let ambientLight = new THREE.AmbientLight(0x404040, 4.1); // soft white light\n        this.sceneZone.add(ambientLight);\n    }\n    /**\n     * Used to initialize the viewer with data.\n     *\n     * @data {object} Data that describes the Brillouin Zone.\n     */\n    setupVisualization(data) {\n        // Add the Brillouin zone and the k-point path\n        let vertices = data[\"vertices\"];\n        let faces = data[\"faces\"];\n        let basis = data[\"basis\"];\n        let segments = data[\"segments\"];\n        let labels = data[\"labels\"];\n        this.basis = data[\"basis\"];\n        if (!vertices || !faces || !basis || !segments) {\n            console.log(\"The data given for the Brillouin zone viewer is incomplete.\");\n            return false;\n        }\n        else {\n            if (!labels) {\n                console.log(\"No labels provided for Brillouin zone viewer.\");\n            }\n            this.createBrillouinZone(vertices, faces, basis, segments, labels);\n        }\n        this.setupInitialView();\n        return true;\n    }\n    /**\n     * Used to setup the visualization according to the given options.\n     */\n    handleSettings(opt) {\n        // The default settings object\n        let options = {\n            controls: {\n                rotateSpeed: 40,\n                enablePan: false\n            },\n            view: {\n                fitMargin: 0.01,\n            },\n            brillouinZone: {\n                segments: {\n                    color: \"#E56400\"\n                }\n            }\n        };\n        this.fillOptions(opt, options);\n        // Handle base class settings\n        super.handleSettings(options);\n    }\n    setupInitialView() {\n        //Rotate the scene so that the first basis vector is pointing up.\n        let yAxis = new THREE.Vector3(0, 1, 0);\n        let xAxis = new THREE.Vector3(1, 0, 0);\n        let zAxis = new THREE.Vector3(0, 0, 1);\n        let direction = new THREE.Vector3().fromArray(this.basis[0]);\n        let quaternion = new THREE.Quaternion().setFromUnitVectors(yAxis, direction.clone().normalize());\n        quaternion.conjugate();\n        this.info.quaternion.copy(quaternion);\n        this.zone.quaternion.copy(quaternion);\n        // Rotate the scene so that the segments are shown properly\n        this.info.updateMatrixWorld(); // The positions are not otherwise updated properly\n        this.zone.updateMatrixWorld();\n        let average = new THREE.Vector3();\n        let nLabelPoints = this.labelPoints.length;\n        for (let iSegmentPoint = 0; iSegmentPoint < nLabelPoints; ++iSegmentPoint) {\n            let segmentPoint = this.labelPoints[iSegmentPoint];\n            average.add(segmentPoint.getWorldPosition(new THREE.Vector3()));\n        }\n        average.multiplyScalar(1 / nLabelPoints);\n        average.y = 0;\n        let segmentQ = new THREE.Quaternion().setFromUnitVectors(zAxis, average.clone().normalize());\n        segmentQ.conjugate();\n        this.info.quaternion.premultiply(segmentQ);\n        this.zone.quaternion.premultiply(segmentQ);\n        // Rotate the zone so that it is shown from slightly above\n        let qX = new THREE.Quaternion();\n        qX.setFromAxisAngle(xAxis, Math.PI / 8);\n        this.info.quaternion.premultiply(qX);\n        this.zone.quaternion.premultiply(qX);\n    }\n    /*\n     * Used to create the representation for the first Brillouin Zone.\n     */\n    createBrillouinZone(vertices, faces, basis, segments, labels) {\n        this.zone = new THREE.Object3D();\n        this.zone.name = \"zone\";\n        this.sceneZone.add(this.zone);\n        this.info = new THREE.Object3D();\n        this.info.name = \"info\";\n        this.sceneInfo.add(this.info);\n        let bzGeometry = new THREE.Geometry();\n        let bzMaterial = new THREE.MeshLambertMaterial({\n            color: 0xeeeeee,\n            side: THREE.DoubleSide,\n            transparent: true,\n            opacity: 0.8\n        });\n        let lineMaterial = new THREE.LineBasicMaterial({\n            color: 0x3333333,\n            linewidth: 2,\n        });\n        // Create vertices\n        for (let iVertex = 0; iVertex < vertices.length; ++iVertex) {\n            let vertex = vertices[iVertex];\n            bzGeometry.vertices.push(new THREE.Vector3().fromArray(vertex).multiplyScalar(1E-10));\n        }\n        // Create faces\n        let faceMap = {};\n        for (let iFace = 0; iFace < faces.length; ++iFace) {\n            let faceIndices = faces[iFace];\n            let nPoints = faceIndices.length;\n            for (let iPoint = 0; iPoint < nPoints; ++iPoint) {\n                // Create edges\n                let firstIndex = faceIndices[iPoint];\n                let secondIndex = faceIndices[(iPoint + 1) % nPoints];\n                let key1 = [firstIndex, secondIndex];\n                let key2 = [secondIndex, firstIndex];\n                if (!faceMap.hasOwnProperty(key1.toString()) && !faceMap.hasOwnProperty(key2.toString())) {\n                    faceMap[key1.toString()] = true;\n                    faceMap[key2.toString()] = true;\n                    let lineGeometry = new THREE.Geometry();\n                    lineGeometry.vertices.push(new THREE.Vector3().fromArray(vertices[firstIndex]).multiplyScalar(1E-10), new THREE.Vector3().fromArray(vertices[secondIndex]).multiplyScalar(1E-10));\n                    let line = new THREE.Line(lineGeometry, lineMaterial);\n                    this.zone.add(line);\n                }\n                // Create surfaces\n                if (iPoint < nPoints - 2) {\n                    let face = new THREE.Face3(faceIndices[0], faceIndices[(iPoint + 1) % nPoints], faceIndices[(iPoint + 2) % nPoints]\n                    //normal\n                    );\n                    bzGeometry.faces.push(face);\n                }\n            }\n        }\n        // Compute normals that are needed for shading the surface\n        bzGeometry.computeFaceNormals();\n        // Create the reciprocal space axes\n        let createAxisLabel = (position, label) => {\n            // Configure canvas\n            let canvas = document.createElement('canvas');\n            let size = 256;\n            canvas.width = size;\n            canvas.height = size;\n            let ctx = canvas.getContext('2d');\n            // Draw label\n            ctx.fillStyle = \"#000000\";\n            ctx.font = \"90px \" + this.options.font.family;\n            ctx.textAlign = \"center\";\n            ctx.fillText(label, size / 2, size / 2);\n            let texture = new THREE.Texture(canvas);\n            texture.needsUpdate = true;\n            let material = new THREE.SpriteMaterial({ map: texture });\n            let sprite = new THREE.Sprite(material);\n            sprite.position.copy(position);\n            let scale = 1 / 11;\n            sprite.scale.set(scale, scale, 1);\n            return sprite;\n        };\n        for (let iBasis = 0; iBasis < 3; ++iBasis) {\n            let length = 0.7;\n            let basisVector = basis[iBasis];\n            let origin = new THREE.Vector3(0, 0, 0);\n            let dir = new THREE.Vector3()\n                .fromArray(basisVector)\n                .multiplyScalar(1E-10)\n                .multiplyScalar(length);\n            // Add a dashed line\n            let lineGeometry = new THREE.Geometry();\n            lineGeometry.vertices.push(origin, dir);\n            let lineMaterial = new THREE.LineDashedMaterial({\n                color: 0x000000,\n                linewidth: 0.1,\n                dashSize: 0.005,\n                gapSize: 0.005\n            });\n            let line = new THREE.Line(lineGeometry, lineMaterial);\n            line.computeLineDistances();\n            this.info.add(line);\n            // Add an axis label\n            let textOffset = 0.020;\n            let textPos = new THREE.Vector3()\n                .copy(dir)\n                .multiplyScalar(1 + textOffset / dir.length());\n            let axisLabel = \"\";\n            switch (iBasis) {\n                case 0:\n                    axisLabel = \"b₁\";\n                    break;\n                case 1:\n                    axisLabel = \"b₂\";\n                    break;\n                case 2:\n                    axisLabel = \"b₃\";\n                    break;\n            }\n            axisLabel = createAxisLabel(textPos, axisLabel);\n            this.info.add(axisLabel);\n            // Add axis arrow\n            let arrowGeometry = new THREE.CylinderGeometry(0, 0.003, 0.012, 12);\n            let arrowMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });\n            let arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);\n            arrow.position.copy(dir);\n            arrow.lookAt(new THREE.Vector3());\n            arrow.rotateX(-Math.PI / 2);\n            this.info.add(arrow);\n        }\n        /*\n         * For creating high symmetry points.\n         */\n        let merged = [].concat.apply([], basis);\n        let basisMatrix = new THREE.Matrix3().fromArray(merged);\n        let labelMap = {};\n        let labelPositions = [];\n        let generateSymmPoint = (position, label) => {\n            // Configure canvas\n            let canvas = document.createElement('canvas');\n            let size = 256;\n            canvas.width = size;\n            canvas.height = size;\n            let ctx = canvas.getContext('2d');\n            // Draw circle\n            ctx.beginPath();\n            ctx.arc(size / 2, size / 2, size / 15, 0, 2 * Math.PI);\n            ctx.fillStyle = this.options.brillouinZone.segments.color;\n            ctx.fill();\n            // Draw label\n            ctx.fillStyle = \"#000000\";\n            ctx.font = \"100px \" + this.options.font.family;\n            ctx.textAlign = \"center\";\n            ctx.fillText(label, canvas.width / 2, 80);\n            let texture = new THREE.Texture(canvas);\n            texture.needsUpdate = true;\n            let material = new THREE.SpriteMaterial({ map: texture });\n            let sprite = new THREE.Sprite(material);\n            sprite.position.copy(position);\n            let scale = 1 / 15;\n            sprite.scale.set(scale, scale, 1);\n            return sprite;\n        };\n        // Create the k-point path from the given segments. Currently assumes\n        // that the segments are linear and the segment path is determined by\n        // the start and end point.\n        let kpathMaterial = new THREE.LineBasicMaterial({\n            color: this.options.brillouinZone.segments.color,\n            linewidth: 3,\n        });\n        let kpathGeometry = new THREE.Geometry();\n        this.labelPoints = [];\n        for (let iSegment = 0; iSegment < segments.length; ++iSegment) {\n            let segment = segments[iSegment];\n            let nKpoints = segment.length;\n            let kPointIndices = [0, nKpoints - 1];\n            for (let iKpoint of kPointIndices) {\n                let kpoint = new THREE.Vector3().fromArray(segment[iKpoint]).multiplyScalar(1E-10);\n                kpoint.applyMatrix3(basisMatrix);\n                kpathGeometry.vertices.push(kpoint);\n                // Create the label for the first point in the segment\n                if (labels) {\n                    if (iKpoint === 0 || iKpoint === nKpoints - 1) {\n                        let label = \"\";\n                        if (iKpoint === 0) {\n                            label = labels[iSegment][0];\n                        }\n                        else if (iKpoint === nKpoints - 1) {\n                            label = labels[iSegment][1];\n                        }\n                        // Check if this position has alread been marked\n                        let labelExists = false;\n                        for (let iLabel = 0; iLabel < this.labelPoints.length; ++iLabel) {\n                            let testPos = this.labelPoints[iLabel].position;\n                            let delta = new THREE.Vector3()\n                                .copy(kpoint)\n                                .addScaledVector(testPos, -1.0)\n                                .length();\n                            if (delta < 1E-5) {\n                                labelExists = true;\n                            }\n                        }\n                        // Add a label position if it wasn't marked already\n                        if (!labelExists) {\n                            labelMap[label] = true;\n                            let symmPoint = generateSymmPoint(kpoint, label);\n                            this.info.add(symmPoint);\n                            this.labelPoints.push(symmPoint);\n                        }\n                    }\n                }\n            }\n        }\n        let kpath = new THREE.Line(kpathGeometry, kpathMaterial);\n        this.info.add(kpath);\n        let mesh = new THREE.Mesh(bzGeometry, bzMaterial);\n        this.zone.add(mesh);\n        this.cornerPoints = new THREE.Points(bzGeometry);\n        this.cornerPoints.visible = true;\n    }\n}\n\n\n//# sourceURL=webpack://matviewer/./src/js/brillouinzoneviewer.js?");

/***/ }),

/***/ "./src/js/entry.js":
/*!*************************!*\
  !*** ./src/js/entry.js ***!
  \*************************/
/*! exports provided: StructureViewer, BrillouinZoneViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _structureviewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structureviewer */ \"./src/js/structureviewer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StructureViewer\", function() { return _structureviewer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _brillouinzoneviewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./brillouinzoneviewer */ \"./src/js/brillouinzoneviewer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BrillouinZoneViewer\", function() { return _brillouinzoneviewer__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n\n\n\n\n\n\n//# sourceURL=webpack://matviewer/./src/js/entry.js?");

/***/ }),

/***/ "./src/js/orthographiccontrols.js":
/*!****************************************!*\
  !*** ./src/js/orthographiccontrols.js ***!
  \****************************************/
/*! exports provided: OrthographicControls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OrthographicControls\", function() { return OrthographicControls; });\n/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Simone Manini / http://daron1337.github.io\n * @author Luca Antiga \t/ http://lantiga.github.io\n * @author Lauri Himanen\n */\nvar changeEvent = new CustomEvent('change');\nvar startEvent = new CustomEvent('start');\nvar endEvent = new CustomEvent('end');\nvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\nvar EPS = 0.000001;\nvar lastPosition = new THREE.Vector3();\nclass OrthographicControls {\n    constructor(object, domElement) {\n        this._state = STATE.NONE;\n        this.object = object;\n        this.domElement = (domElement !== undefined) ? domElement : document;\n        // Public\n        this.enabled = true;\n        this.screen = { left: 0, top: 0, width: 0, height: 0 };\n        this.rotateSpeed = 1.0;\n        this.zoomSpeed = 1.2;\n        this.panSpeed = 0.3;\n        this.enableRotate = true;\n        this.enableZoom = true;\n        this.enablePan = true;\n        this.staticMoving = false;\n        this.dynamicDampingFactor = 0.2;\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n        // Private\n        this.rotationCenter = new THREE.Vector3();\n        this.target = new THREE.Vector3();\n        this._prevState = STATE.NONE,\n            this._eye = new THREE.Vector3(),\n            this._movePrev = new THREE.Vector2(),\n            this._moveCurr = new THREE.Vector2(),\n            this._lastAxis = new THREE.Vector3(),\n            this._lastAngle = 0,\n            this._zoomStart = new THREE.Vector2(),\n            this._zoomEnd = new THREE.Vector2(),\n            this._touchZoomDistanceStart = 0,\n            this._touchZoomDistanceEnd = 0,\n            this._panStart = new THREE.Vector2(),\n            this._panEnd = new THREE.Vector2();\n        this._zoomed = false;\n        // For reset\n        this.rotationCenter0 = this.rotationCenter.clone();\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.up0 = this.object.up.clone();\n        this.domElement.addEventListener('contextmenu', this.contextmenu.bind(this), false);\n        this.domElement.addEventListener('mousedown', this.mousedown.bind(this), false);\n        this.domElement.addEventListener('mousewheel', this.mousewheel, false);\n        this.domElement.addEventListener('MozMousePixelScroll', this.mousewheel.bind(this), false); // firefox\n        this.domElement.addEventListener('touchstart', this.touchstart.bind(this), false);\n        this.domElement.addEventListener('touchend', this.touchend.bind(this), false);\n        this.domElement.addEventListener('touchmove', this.touchmove.bind(this), false);\n        window.addEventListener('keydown', this.keydown.bind(this), false);\n        window.addEventListener('keyup', this.keyup.bind(this), false);\n        window.addEventListener('keydown', this.keydown.bind(this), false);\n        document.addEventListener('mousemove', this.mousemove.bind(this), false);\n        document.addEventListener('mouseup', this.mouseup.bind(this), false);\n        this.handleResize();\n        // force an update at start\n        this.update();\n    }\n    handleResize() {\n        if (this.domElement === document) {\n            this.screen.left = 0;\n            this.screen.top = 0;\n            this.screen.width = window.innerWidth;\n            this.screen.height = window.innerHeight;\n        }\n        else {\n            var box = this.domElement.getBoundingClientRect();\n            // adjustments come from similar code in the jquery offset() function\n            var d = this.domElement.ownerDocument.documentElement;\n            this.screen.left = box.left + window.pageXOffset - d.clientLeft;\n            this.screen.top = box.top + window.pageYOffset - d.clientTop;\n            this.screen.width = box.width;\n            this.screen.height = box.height;\n        }\n    }\n    ;\n    handleEvent(event) {\n        if (typeof this[event.type] == 'function') {\n            this[event.type](event);\n        }\n    }\n    ;\n    getMouseOnScreen(pageX, pageY) {\n        var vector = new THREE.Vector2();\n        vector.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.width);\n        return vector;\n    }\n    ;\n    getMouseOnCircle(pageX, pageY) {\n        var vector = new THREE.Vector2();\n        vector.set(((pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5)), ((this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width) // screen.width intentional\n        );\n        return vector;\n    }\n    ;\n    /**\n      * Used to trigger rotation after a move has been detected and stored in\n      * this.movePrev and this.moveCurr.\n      */\n    rotateCamera() {\n        var axis = new THREE.Vector3(), quaternion = new THREE.Quaternion(), eyeDirection = new THREE.Vector3(), objectUpDirection = new THREE.Vector3(), objectSidewaysDirection = new THREE.Vector3(), moveDirection = new THREE.Vector3(), angle;\n        moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);\n        angle = moveDirection.length();\n        if (angle) {\n            this._eye.copy(this.object.position).sub(this.rotationCenter);\n            eyeDirection.copy(this._eye).normalize();\n            objectUpDirection.copy(this.object.up).normalize();\n            objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();\n            objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);\n            objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);\n            moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\n            axis.crossVectors(moveDirection, this._eye).normalize();\n            var zoomFactor = this.object.zoom;\n            angle *= this.rotateSpeed;\n            angle /= zoomFactor;\n            quaternion.setFromAxisAngle(axis, angle);\n            this._eye.applyQuaternion(quaternion);\n            this.object.up.applyQuaternion(quaternion);\n            this._lastAxis.copy(axis);\n            this._lastAngle = angle;\n        }\n        else if (!this.staticMoving && this._lastAngle) {\n            this._lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);\n            this._eye.copy(this.object.position).sub(this.rotationCenter);\n            quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);\n            this._eye.applyQuaternion(quaternion);\n            this.object.up.applyQuaternion(quaternion);\n        }\n        this._movePrev.copy(this._moveCurr);\n    }\n    ;\n    zoomCamera() {\n        var factor;\n        if (this._state === STATE.TOUCH_ZOOM_PAN) {\n            factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;\n            this._touchZoomDistanceStart = this._touchZoomDistanceEnd;\n            this.object.zoom /= factor;\n            this.object.updateProjectionMatrix();\n            this._zoomed = true;\n        }\n        else {\n            factor = 1.0 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;\n            if (factor !== 1.0 && factor > 0.0) {\n                this.object.zoom /= factor;\n                this.object.updateProjectionMatrix();\n                this._zoomed = true;\n                if (this.staticMoving) {\n                    this._zoomStart.copy(this._zoomEnd);\n                }\n                else {\n                    this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;\n                }\n            }\n        }\n    }\n    ;\n    panCamera() {\n        var mouseChange = new THREE.Vector2(), objectUp = new THREE.Vector3(), pan = new THREE.Vector3();\n        mouseChange.copy(this._panEnd).sub(this._panStart);\n        if (mouseChange.lengthSq()) {\n            var zoomFactor = this.object.zoom;\n            mouseChange.multiplyScalar(this.panSpeed / zoomFactor);\n            pan.copy(this._eye).cross(this.object.up).setLength(mouseChange.x);\n            pan.add(objectUp.copy(this.object.up).setLength(mouseChange.y));\n            this.object.position.add(pan);\n            this.rotationCenter.add(pan);\n            if (this.staticMoving) {\n                this._panStart.copy(this._panEnd);\n            }\n            else {\n                this._panStart.add(mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));\n            }\n        }\n        ;\n    }\n    ;\n    checkDistances() {\n        if (this.enableZoom || this.enablePan) {\n            if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {\n                this.object.position.addVectors(this.rotationCenter, this._eye.setLength(this.maxDistance));\n                this._zoomStart.copy(this._zoomEnd);\n            }\n            if (this._eye.lengthSq() < this.minDistance * this.minDistance) {\n                this.object.position.addVectors(this.rotationCenter, this._eye.setLength(this.minDistance));\n                this._zoomStart.copy(this._zoomEnd);\n            }\n        }\n    }\n    ;\n    /**\n      * Used to update the controlled object after the user has manipulated the\n      * scene. Will also request a new render if the manipulation has changed\n      * the scene.\n      */\n    update() {\n        this._eye.subVectors(this.object.position, this.rotationCenter);\n        if (this.enableRotate) {\n            this.rotateCamera();\n        }\n        if (this.enableZoom) {\n            this.zoomCamera();\n        }\n        if (this.enablePan) {\n            this.panCamera();\n        }\n        this.object.position.addVectors(this.rotationCenter, this._eye);\n        this.checkDistances();\n        this.object.lookAt(this.rotationCenter);\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || this._zoomed) {\n            this.dispatchEvent(changeEvent);\n            lastPosition.copy(this.object.position);\n            this._zoomed = false;\n        }\n    }\n    ;\n    reset() {\n        this._state = STATE.NONE;\n        this._prevState = STATE.NONE;\n        this.rotationCenter.copy(this.rotationCenter0);\n        this.object.position.copy(this.position0);\n        this.object.up.copy(this.up0);\n        this._eye.subVectors(this.object.position, this.rotationCenter);\n        this.object.lookAt(this.rotationCenter);\n        this.dispatchEvent(changeEvent);\n        lastPosition.copy(this.object.position);\n    }\n    ;\n    dispose() {\n        this.domElement.removeEventListener('contextmenu', this.contextmenu.bind(this), false);\n        this.domElement.removeEventListener('mousedown', this.mousedown.bind(this), false);\n        this.domElement.removeEventListener('mousewheel', this.mousewheel.bind(this), false);\n        this.domElement.removeEventListener('MozMousePixelScroll', this.mousewheel.bind(this), false); // firefox\n        this.domElement.removeEventListener('touchstart', this.touchstart.bind(this), false);\n        this.domElement.removeEventListener('touchend', this.touchend.bind(this), false);\n        this.domElement.removeEventListener('touchmove', this.touchmove.bind(this), false);\n        document.removeEventListener('mousemove', this.mousemove.bind(this), false);\n        document.removeEventListener('mouseup', this.mouseup.bind(this), false);\n        window.removeEventListener('keydown', this.keydown.bind(this), false);\n        window.removeEventListener('keyup', this.keyup.bind(this), false);\n    }\n    ;\n    keydown(event) {\n        if (this.enabled === false)\n            return;\n        window.removeEventListener('keydown', this.keydown.bind(this));\n        this._prevState = this._state;\n        if (this._state !== STATE.NONE) {\n            return;\n        }\n        else if (event.keyCode === this.keys[STATE.ROTATE] && this.enableRotate) {\n            this._state = STATE.ROTATE;\n        }\n        else if (event.keyCode === this.keys[STATE.ZOOM] && this.enableZoom) {\n            this._state = STATE.ZOOM;\n        }\n        else if (event.keyCode === this.keys[STATE.PAN] && this.enablePan) {\n            this._state = STATE.PAN;\n        }\n    }\n    keyup(event) {\n        if (this.enabled === false)\n            return;\n        this._state = this._prevState;\n    }\n    mousedown(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        if (this._state === STATE.NONE) {\n            this._state = event.button;\n        }\n        if (this._state === STATE.ROTATE && this.enableRotate) {\n            this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));\n            this._movePrev.copy(this._moveCurr);\n        }\n        else if (this._state === STATE.ZOOM && this.enableZoom) {\n            this._zoomStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n            this._zoomEnd.copy(this._zoomStart);\n        }\n        else if (this._state === STATE.PAN && this.enablePan) {\n            this._panStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n            this._panEnd.copy(this._panStart);\n        }\n        this.dispatchEvent(startEvent);\n    }\n    mousemove(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        if (this._state === STATE.ROTATE && this.enableRotate) {\n            this._movePrev.copy(this._moveCurr);\n            this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));\n        }\n        else if (this._state === STATE.ZOOM && this.enableZoom) {\n            this._zoomEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n        }\n        else if (this._state === STATE.PAN && this.enablePan) {\n            this._panEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n        }\n        // Trigger update after moving mouse\n        this.update();\n    }\n    mouseup(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        this._state = STATE.NONE;\n        document.removeEventListener('mousemove', this.mousemove.bind(this));\n        document.removeEventListener('mouseup', this.mouseup.bind(this));\n        this.dispatchEvent(endEvent);\n    }\n    mousewheel(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        var delta = 0;\n        if (event.wheelDelta) {\n            // WebKit / Opera / Explorer 9\n            delta = event.wheelDelta / 40;\n        }\n        else if (event.detail) {\n            // Firefox\n            delta = -event.detail / 3;\n        }\n        this._zoomStart.y += delta * 0.01;\n        this.dispatchEvent(startEvent);\n        this.dispatchEvent(endEvent);\n        // Trigger update after wheel scroll\n        this.update();\n    }\n    touchstart(event) {\n        if (this.enabled === false)\n            return;\n        switch (event.touches.length) {\n            case 1:\n                this._state = STATE.TOUCH_ROTATE;\n                this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                this._movePrev.copy(this._moveCurr);\n                break;\n            default: // 2 or more\n                this._state = STATE.TOUCH_ZOOM_PAN;\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n                this._panStart.copy(this.getMouseOnScreen(x, y));\n                this._panEnd.copy(this._panStart);\n                break;\n        }\n        this.dispatchEvent(startEvent);\n    }\n    touchmove(event) {\n        if (this.enabled === false)\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n        switch (event.touches.length) {\n            case 1:\n                this._movePrev.copy(this._moveCurr);\n                this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                break;\n            default: // 2 or more\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n                this._panEnd.copy(this.getMouseOnScreen(x, y));\n                break;\n        }\n        // Trigger update after touch move\n        this.update();\n    }\n    touchend(event) {\n        if (this.enabled === false)\n            return;\n        switch (event.touches.length) {\n            case 0:\n                this._state = STATE.NONE;\n                break;\n            case 1:\n                this._state = STATE.TOUCH_ROTATE;\n                this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                this._movePrev.copy(this._moveCurr);\n                break;\n        }\n        this.dispatchEvent(endEvent);\n    }\n    contextmenu(event) {\n        event.preventDefault();\n    }\n    addEventListener(type, listener) {\n        if (this._listeners === undefined)\n            this._listeners = {};\n        var listeners = this._listeners;\n        if (listeners[type] === undefined) {\n            listeners[type] = [];\n        }\n        if (listeners[type].indexOf(listener) === -1) {\n            listeners[type].push(listener);\n        }\n    }\n    hasEventListener(type, listener) {\n        if (this._listeners === undefined)\n            return false;\n        var listeners = this._listeners;\n        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n        if (this._listeners === undefined)\n            return;\n        var listeners = this._listeners;\n        var listenerArray = listeners[type];\n        if (listenerArray !== undefined) {\n            var index = listenerArray.indexOf(listener);\n            if (index !== -1) {\n                listenerArray.splice(index, 1);\n            }\n        }\n    }\n    dispatchEvent(event) {\n        if (this._listeners === undefined)\n            return;\n        var listeners = this._listeners;\n        var listenerArray = listeners[event.type];\n        if (listenerArray !== undefined) {\n            var array = listenerArray.slice(0);\n            for (var i = 0, l = array.length; i < l; i++) {\n                array[i].call(this, event);\n            }\n        }\n    }\n}\n;\n\n\n//# sourceURL=webpack://matviewer/./src/js/orthographiccontrols.js?");

/***/ }),

/***/ "./src/js/structureviewer.js":
/*!***********************************!*\
  !*** ./src/js/structureviewer.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StructureViewer; });\n/* harmony import */ var _viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer */ \"./src/js/viewer.js\");\n\n/**\n * Class for visualizing a 3D crystal structure. Uses three.js to do the\n * visualization with WegGL or alternatively in html5 canvas.\n */\nclass StructureViewer extends _viewer__WEBPACK_IMPORTED_MODULE_0__[\"Viewer\"] {\n    constructor() {\n        super(...arguments);\n        this.axisLabels = []; // List of all labels in the view.\n        this.wrapTolerance = 0.05; // Tolerance of the wrapping in Angstroms\n        this.tagColorMap = {\n            \"adsorbates\": \"0xd70000\",\n            \"unknowns\": \"0xd75f00\",\n            \"interstitials\": \"0xaf8700\",\n            \"substitutions\": \"0x0087ff\",\n            \"outliers\": \"0x0087ff\"\n        };\n        this.elementNames = [\n            'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si',\n            'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni',\n            'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb',\n            'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe',\n            'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho',\n            'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',\n            'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np',\n            'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Ha', 'Sg',\n            'Ns', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og' // Mt = 109\n        ];\n        this.elementNumbers = {\n            'H': 1, 'He': 2, 'Li': 3, 'Be': 4,\n            'B': 5, 'C': 6, 'N': 7, 'O': 8, 'F': 9,\n            'Ne': 10, 'Na': 11, 'Mg': 12, 'Al': 13, 'Si': 14,\n            'P': 15, 'S': 16, 'Cl': 17, 'Ar': 18, 'K': 19,\n            'Ca': 20, 'Sc': 21, 'Ti': 22, 'V': 23, 'Cr': 24,\n            'Mn': 25, 'Fe': 26, 'Co': 27, 'Ni': 28, 'Cu': 29,\n            'Zn': 30, 'Ga': 31, 'Ge': 32, 'As': 33, 'Se': 34,\n            'Br': 35, 'Kr': 36, 'Rb': 37, 'Sr': 38, 'Y': 39,\n            'Zr': 40, 'Nb': 41, 'Mo': 42, 'Tc': 43, 'Ru': 44,\n            'Rh': 45, 'Pd': 46, 'Ag': 47, 'Cd': 48, 'In': 49,\n            'Sn': 50, 'Sb': 51, 'Te': 52, 'I': 53, 'Xe': 54,\n            'Cs': 55, 'Ba': 56, 'La': 57, 'Ce': 58, 'Pr': 59,\n            'Nd': 60, 'Pm': 61, 'Sm': 62, 'Eu': 63, 'Gd': 64,\n            'Tb': 65, 'Dy': 66, 'Ho': 67, 'Er': 68, 'Tm': 69,\n            'Yb': 70, 'Lu': 71, 'Hf': 72, 'Ta': 73, 'W': 74,\n            'Re': 75, 'Os': 76, 'Ir': 77, 'Pt': 78, 'Au': 79,\n            'Hg': 80, 'Tl': 81, 'Pb': 82, 'Bi': 83, 'Po': 84,\n            'At': 85, 'Rn': 86, 'Fr': 87, 'Ra': 88, 'Ac': 89,\n            'Th': 90, 'Pa': 91, 'U': 92, 'Np': 93, 'Pu': 94,\n            'Am': 95, 'Cm': 96, 'Bk': 97, 'Cf': 98, 'Es': 99,\n            'Fm': 100, 'Md': 101, 'No': 102, 'Lr': 103,\n        };\n        //  Covalent radii revisited,\n        //  Beatriz Cordero, Verónica Gómez, Ana E. Platero-Prats, Marc Revés,\n        //  Jorge Echeverría, Eduard Cremades, Flavia Barragán and Santiago Alvarez,\n        //  Dalton Trans., 2008, 2832-2838 DOI:10.1039/B801115J\n        this.missing = 0.2;\n        this.elementRadii = [\n            this.missing,\n            0.31,\n            0.28,\n            1.28,\n            0.96,\n            0.84,\n            0.76,\n            0.71,\n            0.66,\n            0.57,\n            0.58,\n            1.66,\n            1.41,\n            1.21,\n            1.11,\n            1.07,\n            1.05,\n            1.02,\n            1.06,\n            2.03,\n            1.76,\n            1.7,\n            1.6,\n            1.53,\n            1.39,\n            1.39,\n            1.32,\n            1.26,\n            1.24,\n            1.32,\n            1.22,\n            1.22,\n            1.2,\n            1.19,\n            1.2,\n            1.2,\n            1.16,\n            2.2,\n            1.95,\n            1.9,\n            1.75,\n            1.64,\n            1.54,\n            1.47,\n            1.46,\n            1.42,\n            1.39,\n            1.45,\n            1.44,\n            1.42,\n            1.39,\n            1.39,\n            1.38,\n            1.39,\n            1.4,\n            2.44,\n            2.15,\n            2.07,\n            2.04,\n            2.03,\n            2.01,\n            1.99,\n            1.98,\n            1.98,\n            1.96,\n            1.94,\n            1.92,\n            1.92,\n            1.89,\n            1.9,\n            1.87,\n            1.87,\n            1.75,\n            1.7,\n            1.62,\n            1.51,\n            1.44,\n            1.41,\n            1.36,\n            1.36,\n            1.32,\n            1.45,\n            1.46,\n            1.48,\n            1.4,\n            1.5,\n            1.5,\n            2.6,\n            2.21,\n            2.15,\n            2.06,\n            2.0,\n            1.96,\n            1.9,\n            1.87,\n            1.8,\n            1.69,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n            this.missing,\n        ];\n        // Jmol colors. See: http://jmol.sourceforge.net/jscolors/#color_U\n        this.elementColors = [\n            0xff0000,\n            0xffffff,\n            0xd9ffff,\n            0xcc80ff,\n            0xc2ff00,\n            0xffb5b5,\n            0x909090,\n            0x3050f8,\n            0xff0d0d,\n            0x90e050,\n            0xb3e3f5,\n            0xab5cf2,\n            0x8aff00,\n            0xbfa6a6,\n            0xf0c8a0,\n            0xff8000,\n            0xffff30,\n            0x1ff01f,\n            0x80d1e3,\n            0x8f40d4,\n            0x3dff00,\n            0xe6e6e6,\n            0xbfc2c7,\n            0xa6a6ab,\n            0x8a99c7,\n            0x9c7ac7,\n            0xe06633,\n            0xf090a0,\n            0x50d050,\n            0xc88033,\n            0x7d80b0,\n            0xc28f8f,\n            0x668f8f,\n            0xbd80e3,\n            0xffa100,\n            0xa62929,\n            0x5cb8d1,\n            0x702eb0,\n            0x00ff00,\n            0x94ffff,\n            0x94e0e0,\n            0x73c2c9,\n            0x54b5b5,\n            0x3b9e9e,\n            0x248f8f,\n            0x0a7d8c,\n            0x006985,\n            0xc0c0c0,\n            0xffd98f,\n            0xa67573,\n            0x668080,\n            0x9e63b5,\n            0xd47a00,\n            0x940094,\n            0x429eb0,\n            0x57178f,\n            0x00c900,\n            0x70d4ff,\n            0xffffc7,\n            0xd9ffc7,\n            0xc7ffc7,\n            0xa3ffc7,\n            0x8fffc7,\n            0x61ffc7,\n            0x45ffc7,\n            0x30ffc7,\n            0x1fffc7,\n            0x00ff9c,\n            0x00e675,\n            0x00d452,\n            0x00bf38,\n            0x00ab24,\n            0x4dc2ff,\n            0x4da6ff,\n            0x2194d6,\n            0x267dab,\n            0x266696,\n            0x175487,\n            0xd0d0e0,\n            0xffd123,\n            0xb8b8d0,\n            0xa6544d,\n            0x575961,\n            0x9e4fb5,\n            0xab5c00,\n            0x754f45,\n            0x428296,\n            0x420066,\n            0x007d00,\n            0x70abfa,\n            0x00baff,\n            0x00a1ff,\n            0x008fff,\n            0x0080ff,\n            0x006bff,\n            0x545cf2,\n            0x785ce3,\n            0x8a4fe3,\n            0xa136d4,\n            0xb31fd4,\n            0xb31fba,\n            0xb30da6,\n            0xbd0d87,\n            0xc70066,\n            0xcc0059,\n            0xd1004f,\n            0xd90045,\n            0xe00038,\n            0xe6002e,\n            0xeb0026,\n        ];\n    }\n    /*\n     * Overrides the implementation from the base class, as we need two scenes:\n     * one for the structure and another for the information that is laid on top.\n     */\n    setupScenes() {\n        this.scenes = [];\n        this.sceneStructure = new THREE.Scene();\n        this.scenes.push(this.sceneStructure);\n        this.sceneInfo = new THREE.Scene();\n        this.scenes.push(this.sceneInfo);\n    }\n    /**\n     * Used to setup the visualization according to the given options.\n     */\n    handleSettings(opt) {\n        let options = {\n            view: {\n                fitMargin: 0.5,\n            },\n            structure: {\n                showParam: true,\n                createLegend: true,\n                showLegend: true,\n                showBonds: true,\n                allowRepeat: true,\n                showCopies: false,\n                showCell: true,\n                wrap: true,\n                radiusScale: 1,\n                bondScale: 1,\n                translation: [0, 0, 0],\n                viewCenter: \"COP\",\n                showShadows: false,\n            },\n        };\n        this.fillOptions(opt, options);\n        // Handle base class settings\n        super.handleSettings(options);\n    }\n    /**\n     * Setup the structure visualization based on the given data.\n     *\n     * @param {Object} data -  The structure data. Contains the following\n     * attributes:\n     *\n     *     - cell\n     *     - scaledPositions\n     *     - atomicNumbers\n     *     - primitiveCell (optional)\n     *     - pbc (optional)\n     *     - unit (optional): An unit cell from which a larger piece is\n     *          composed of\n     *     - tags (optional): The indices for certain special atoms in the system.\n     */\n    setupVisualization(data) {\n        // Check that the received data is OK.\n        let primitiveCell = data[\"primitiveCell\"];\n        let cell = data[\"cell\"];\n        let scaledPositions = data[\"scaledPositions\"];\n        let positions = data[\"positions\"];\n        let atomicNumbers = data[\"atomicNumbers\"];\n        let chemicalSymbols = data[\"chemicalSymbols\"];\n        let periodicity = data[\"pbc\"];\n        let bonds = data[\"bonds\"];\n        this.tags = data[\"tags\"];\n        if (!scaledPositions && !positions) {\n            console.log(\"No atom positions given to the structure viewer\");\n            return false;\n        }\n        if (!atomicNumbers && !chemicalSymbols) {\n            console.log(\"No atomicNumbers or chemicalSymbols given to the structure viewer.\");\n            return false;\n        }\n        // Determine the atomicNumbers if not given\n        if (!atomicNumbers) {\n            atomicNumbers = chemicalSymbols.map(symb => {\n                return this.elementNumbers[symb];\n            });\n        }\n        ;\n        // If bonds are not explicitly stated, determine them automatically.\n        if (!bonds) {\n            bonds == \"auto\";\n        }\n        else {\n            if (bonds != \"off\" && bonds != \"auto\" && !Array.isArray(bonds)) {\n                console.log(\"Invalid value for 'bonds'. Use either 'auto', 'off' or provide a list of index pairs. If not defined, 'auto' is assumed.\");\n                return false;\n            }\n        }\n        if (positions) {\n            if (positions.length != atomicNumbers.length) {\n                console.log(\"The number of positions does not match the number of labels.\");\n                return false;\n            }\n        }\n        if (scaledPositions) {\n            if (scaledPositions.length != atomicNumbers.length) {\n                console.log(\"The number of scaled positions does not match the number of labels.\");\n                return false;\n            }\n        }\n        // Assume 3D periodicity if not defined\n        if ((periodicity == undefined) || (periodicity == null)) {\n            periodicity = [true, true, true];\n        }\n        this.root = new THREE.Object3D();\n        this.atoms = new THREE.Object3D();\n        this.bonds = new THREE.Object3D();\n        this.cellVectorLines = new THREE.Object3D();\n        this.angleArcs = new THREE.Object3D();\n        this.root.add(this.cellVectorLines);\n        this.root.add(this.atoms);\n        this.root.add(this.bonds);\n        this.sceneStructure.add(this.root);\n        this.basisVectors = this.createBasisVectors(cell);\n        let relPos = [];\n        let cartPos = [];\n        // Create a set of relative and cartesian positions\n        if (scaledPositions !== undefined) {\n            for (let i = 0; i < scaledPositions.length; ++i) {\n                let pos = scaledPositions[i];\n                let iRelPos = new THREE.Vector3().fromArray(pos);\n                // Wrap the positions\n                let x = iRelPos.x;\n                let y = iRelPos.y;\n                let z = iRelPos.z;\n                if (this.options.structure.wrap) {\n                    if (periodicity[0] && this.almostEqual(1, x, this.basisVectors[0], this.wrapTolerance)) {\n                        x -= 1;\n                    }\n                    if (periodicity[1] && this.almostEqual(1, y, this.basisVectors[1], this.wrapTolerance)) {\n                        y -= 1;\n                    }\n                    if (periodicity[2] && this.almostEqual(1, z, this.basisVectors[2], this.wrapTolerance)) {\n                        z -= 1;\n                    }\n                }\n                iRelPos = new THREE.Vector3(x, y, z);\n                relPos.push(iRelPos);\n                let iCartPos = new THREE.Vector3();\n                iCartPos.add(this.basisVectors[0].clone().multiplyScalar(iRelPos.x));\n                iCartPos.add(this.basisVectors[1].clone().multiplyScalar(iRelPos.y));\n                iCartPos.add(this.basisVectors[2].clone().multiplyScalar(iRelPos.z));\n                cartPos.push(iCartPos);\n            }\n        }\n        else if (positions !== undefined) {\n            for (let i = 0; i < positions.length; ++i) {\n                let pos = positions[i];\n                let iCartPos = new THREE.Vector3().fromArray(pos);\n                cartPos.push(iCartPos);\n                // Calculate the relative positions\n                let cellMatrix = new THREE.Matrix3();\n                cellMatrix.set(cell[0][0], cell[0][1], cell[0][2], cell[1][0], cell[1][1], cell[1][2], cell[2][0], cell[2][1], cell[2][2]);\n                let cellInverse = new THREE.Matrix3().getInverse(cellMatrix);\n                let iRelPos = iCartPos.clone().applyMatrix3(cellInverse);\n                relPos.push(iRelPos);\n            }\n        }\n        // Determine the periodicity and setup the vizualization accordingly\n        let nPeriodic = 0;\n        let periodicIndices = [];\n        let p1 = periodicity[0];\n        let p2 = periodicity[1];\n        let p3 = periodicity[2];\n        if (p1 && p2 && p3) {\n            nPeriodic = 3;\n        }\n        else if (!p1 && !p2 && !p3) {\n            nPeriodic = 0;\n        }\n        else {\n            for (let dim = 0; dim < 3; ++dim) {\n                let p1 = periodicity[dim];\n                let p2 = periodicity[(dim + 1) % 3];\n                let p3 = periodicity[(dim + 2) % 3];\n                if (p1 && !p2 && !p3) {\n                    nPeriodic = 1;\n                    periodicIndices.push(dim);\n                    break;\n                }\n                else if (p1 && p2 && !p3) {\n                    nPeriodic = 2;\n                    periodicIndices.push(dim);\n                    periodicIndices.push((dim + 1) % 3);\n                    break;\n                }\n            }\n        }\n        if (nPeriodic === 0) {\n            this.setup0D(relPos, cartPos, atomicNumbers);\n        }\n        if (nPeriodic === 1) {\n            this.setup1D(relPos, cartPos, atomicNumbers, periodicity, periodicIndices);\n        }\n        else if (nPeriodic === 2) {\n            this.setup2D(relPos, cartPos, atomicNumbers, periodicity, periodicIndices);\n        }\n        else if (nPeriodic === 3) {\n            this.setup3D(relPos, cartPos, atomicNumbers);\n        }\n        // Determine the corner points that are used to properly fit the\n        // structure into the viewer. The fit takes also into account the\n        // periodic duplicates and atoms created at the boundary.\n        this.createVisualizationBoundaryPositions(this.atomPos, atomicNumbers);\n        // Create bonds\n        this.createBonds(bonds);\n        // Setup the view center\n        let viewCenter = this.options.structure.viewCenter;\n        let centerPos;\n        // Center of positions takes into account also the repeated positions\n        // and positions created at the cell boundaries.\n        if (viewCenter === \"COP\") {\n            centerPos = this.calculateCOP(this.atomPos);\n        }\n        else if (viewCenter === \"COC\") {\n            centerPos = new THREE.Vector3()\n                .add(this.basisVectors[0])\n                .add(this.basisVectors[1])\n                .add(this.basisVectors[2])\n                .multiplyScalar(0.5);\n        }\n        else if (Array.isArray(viewCenter)) {\n            centerPos = new THREE.Vector3().fromArray(viewCenter);\n        }\n        this.setViewCenter(centerPos);\n        // Translate the system according to given option\n        this.translate(this.options.structure.translation);\n        // Zoom according to given option\n        this.setZoom(this.options.controls.zoomLevel);\n        // Setup element legend and settings\n        if (this.options.structure.createLegend) {\n            this.createElementLegend();\n        }\n        return true;\n    }\n    /**\n     *\n     */\n    calculateCOP(positions) {\n        let nPos = positions.length;\n        let sum = new THREE.Vector3();\n        for (let i = 0; i < nPos; ++i) {\n            let pos = positions[i];\n            sum.add(pos);\n        }\n        sum.divideScalar(nPos);\n        return sum;\n    }\n    /**\n     * Centers the visualization around a specific point.\n     * @param centerPos - The center position as a cartesian vector.\n     */\n    setViewCenter(centerPos) {\n        this.cornerPoints.position.sub(centerPos);\n        this.atoms.position.sub(centerPos);\n        this.bonds.position.sub(centerPos);\n        this.latticeParameters.position.sub(centerPos);\n        this.angleArcs.position.sub(centerPos);\n        this.convCell.position.sub(centerPos);\n        this.render();\n    }\n    /**\n     * Translate the atoms.\n     *\n     * @param translation - Cartesian translation to apply.\n     */\n    translate(translation) {\n        let vec = new THREE.Vector3().fromArray(translation);\n        this.atoms.position.add(vec);\n        this.bonds.position.add(vec);\n        this.render();\n    }\n    /**\n     * Set the zoom level\n     *\n     * @param zoomLevel - The zoom level as a scalar.\n     */\n    setZoom(zoomLevel) {\n        this.camera.zoom = zoomLevel;\n        this.render();\n    }\n    /**\n     * This function will setup the dat.gui based settings window amd the\n     * element legend div.\n     */\n    setupStatic() {\n        if (this.options.structure.createLegend) {\n            // Setup div containing the element labels\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'elementlegend';\n            this.elementLegend = legendDiv;\n            this.rootElement.appendChild(legendDiv);\n        }\n    }\n    setupLights() {\n        this.lights = [];\n        let shadowMapWidth = 2048;\n        // Key light\n        let keyLight = new THREE.DirectionalLight(0xffffff, 0.45);\n        keyLight.shadow.mapSize.width = shadowMapWidth;\n        keyLight.shadow.mapSize.height = shadowMapWidth;\n        keyLight.position.set(0, 0, 20);\n        this.sceneStructure.add(keyLight);\n        this.lights.push(keyLight);\n        // Fill light\n        let fillLight = new THREE.DirectionalLight(0xffffff, 0.3);\n        fillLight.shadow.mapSize.width = shadowMapWidth;\n        fillLight.shadow.mapSize.height = shadowMapWidth;\n        fillLight.position.set(-20, 0, -20);\n        this.sceneStructure.add(fillLight);\n        this.lights.push(fillLight);\n        // Back light\n        let backLight = new THREE.DirectionalLight(0xffffff, 0.25);\n        backLight.shadow.mapSize.width = shadowMapWidth;\n        backLight.shadow.mapSize.height = shadowMapWidth;\n        backLight.position.set(20, 0, -20);\n        //backLight.position.set( 0, 0, -20 );\n        this.sceneStructure.add(backLight);\n        this.lights.push(backLight);\n        // White ambient light.\n        let ambientLight = new THREE.AmbientLight(0x404040, 1.7); // soft white light\n        this.sceneStructure.add(ambientLight);\n    }\n    /**\n     *\n     */\n    toggleElementLegend(value) {\n        if (value) {\n            this.elementLegend.style.display = \"flex\";\n        }\n        else {\n            this.elementLegend.style.display = \"None\";\n        }\n    }\n    /**\n     * Hides or shows the lattice parameter labels.\n     */\n    toggleLatticeParameters(value) {\n        this.latticeParameters.visible = value;\n        this.cellVectorLines.visible = value;\n        this.angleArcs.visible = value;\n        this.render();\n    }\n    /**\n     * Hides or shows the cell.\n     */\n    toggleCell(value) {\n        if (this.convCell !== undefined) {\n            this.convCell.visible = value;\n        }\n        if (this.primCell !== undefined) {\n            this.primCell.visible = value;\n        }\n        this.render();\n    }\n    /**\n     * Hides or shows the bonds.\n     */\n    toggleBonds(value) {\n        this.bonds.visible = value;\n        this.render();\n    }\n    /**\n     * Hides or shows the shadows.\n     */\n    toggleShadows(value) {\n        this.renderer.shadowMap.enabled = value;\n        for (let i = 0; i < this.lights.length; ++i) {\n            let light = this.lights[i];\n            light.castShadow = value;\n        }\n        for (let i = 0; i < this.atomFills.length; ++i) {\n            let atom = this.atomFills[i];\n            atom.receiveShadow = value;\n            atom.castShadow = value;\n            atom.material.needsUpdate = true;\n        }\n        for (let i = 0; i < this.bondFills.length; ++i) {\n            let bond = this.bondFills[i];\n            bond.receiveShadow = value;\n            bond.castShadow = value;\n            bond.material.needsUpdate = true;\n        }\n        // For some reason double rendering is required... Maybe delay()?\n        this.render();\n        this.render();\n    }\n    /**\n     *\n     */\n    createElementLegend() {\n        // Empty the old legend\n        while (this.elementLegend.firstChild) {\n            this.elementLegend.removeChild(this.elementLegend.firstChild);\n        }\n        // Create a list of elements\n        let elementArray = [];\n        for (let property in this.elements) {\n            if (this.elements.hasOwnProperty(property)) {\n                elementArray.push([property, this.elements[property][0], this.elements[property][1]]);\n            }\n        }\n        // Sort by name\n        elementArray.sort(function (a, b) {\n            let keyA = a[0];\n            let keyB = b[0];\n            if (keyA < keyB)\n                return -1;\n            if (keyA > keyB)\n                return 1;\n            return 0;\n        });\n        for (let iElem = 0; iElem < elementArray.length; ++iElem) {\n            let elementName = elementArray[iElem][0];\n            let elementColor = elementArray[iElem][1].toString(16);\n            let nZeros = 6 - elementColor.length;\n            let prefix = \"#\" + Array(nZeros + 1).join(\"0\");\n            elementColor = prefix + elementColor;\n            let elementRadius = 50 * elementArray[iElem][2];\n            // Containing sphere\n            let elemDiv = document.createElement('div');\n            elemDiv.className = \"elementlabel\";\n            elemDiv.style.backgroundColor = elementColor;\n            elemDiv.style.height = elementRadius + \"px\";\n            elemDiv.style.width = elementRadius + \"px\";\n            elemDiv.style.textAlign = \"center\";\n            elemDiv.style.verticalAlign = \"middle\";\n            elemDiv.style.lineHeight = elementRadius + \"px\";\n            elemDiv.style.borderRadius = elementRadius / 2 + \"px\";\n            elemDiv.textContent = elementName;\n            // Label inside\n            this.elementLegend.appendChild(elemDiv);\n        }\n    }\n    /**\n     * Create the visuals to show the lattice parameter labels.\n     */\n    createLatticeParameters(basis, periodicity, periodicIndices) {\n        this.latticeParameters = new THREE.Object3D();\n        this.axisLabels = [];\n        this.sceneInfo.add(this.latticeParameters);\n        this.sceneInfo.add(this.angleArcs);\n        let nPeriod = 0;\n        let infoColor = 0x000000;\n        for (let iDim = 0; iDim < periodicity.length; ++iDim) {\n            if (periodicity[iDim]) {\n                ++nPeriod;\n            }\n        }\n        // Used to create a text label as sprite that lives in 3D space.\n        let createLabel = (position, label, color, stroked = true) => {\n            // Configure canvas\n            let canvas = document.createElement('canvas');\n            let size = 256;\n            canvas.width = size;\n            canvas.height = size;\n            let ctx = canvas.getContext('2d');\n            // Draw label\n            ctx.fillStyle = color;\n            //ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"155px \" + this.options.font.family;\n            ctx.textAlign = \"center\";\n            if (stroked) {\n                ctx.font = \"160px \" + this.options.font.family;\n                ctx.lineWidth = 8;\n                ctx.strokeStyle = \"#000000\";\n                ctx.strokeText(label, size / 2, size / 2);\n            }\n            ctx.fillText(label, size / 2, size / 2);\n            let texture = new THREE.Texture(canvas);\n            texture.needsUpdate = true;\n            let material = new THREE.SpriteMaterial({ map: texture });\n            let sprite = new THREE.Sprite(material);\n            sprite.position.copy(position);\n            let scale = 1.5;\n            sprite.scale.set(scale, scale, 1);\n            return sprite;\n        };\n        let axisMaterial = new THREE.LineBasicMaterial({\n            color: \"#000000\",\n            linewidth: 1.5\n        });\n        let axisOffset = 1.3;\n        let cellBasisColors = [\"#C52929\", \"#47A823\", \"#3B5796\"];\n        let iBasis = -1;\n        let axisLabels = [\"a\", \"b\", \"c\"];\n        let angleLabels = [\"γ\", \"α\", \"β\"];\n        // If 2D periodic, we save the periodic indices, and ensure a right\n        // handed coordinate system.\n        let first;\n        let second;\n        if (nPeriod === 2) {\n            first = periodicIndices[0];\n            second = periodicIndices[1];\n        }\n        for (let iTrueBasis = 0; iTrueBasis < 3; ++iTrueBasis) {\n            if (!periodicity[iTrueBasis]) {\n                continue;\n            }\n            iBasis += 1;\n            let axisLabel = axisLabels[iBasis];\n            let axisColor = cellBasisColors[iBasis];\n            // Basis and angle label selection, same for all systems\n            let angleLabel = angleLabels[iBasis];\n            let basisVec1 = basis[iTrueBasis];\n            let basisVec2 = basis[(iTrueBasis + 1) % 3].clone();\n            let basisVec3 = basis[(iTrueBasis + 2) % 3].clone();\n            let origin = new THREE.Vector3(0, 0, 0);\n            let dir = basisVec1.clone();\n            // Add an axis label\n            let textPos = dir.clone()\n                .multiplyScalar(0.5);\n            let labelOffset;\n            let newBasis2;\n            let newBasis3;\n            if (basisVec2.length() == 0) {\n                newBasis2 = new THREE.Vector3().crossVectors(basisVec1, basisVec3);\n                labelOffset = new THREE.Vector3().crossVectors(basisVec1, newBasis2);\n            }\n            else if (basisVec3.length() == 0) {\n                newBasis3 = new THREE.Vector3().crossVectors(basisVec1, basisVec2);\n                labelOffset = new THREE.Vector3().crossVectors(basisVec1, basisVec3);\n            }\n            else {\n                let labelOffset1 = new THREE.Vector3().crossVectors(basisVec1, basisVec2);\n                let labelOffset2 = new THREE.Vector3().crossVectors(basisVec1, basisVec3);\n                labelOffset = new THREE.Vector3().sub(labelOffset1).add(labelOffset2);\n            }\n            labelOffset.normalize();\n            labelOffset.multiplyScalar(0.8);\n            textPos.add(labelOffset);\n            if (nPeriod === 3) {\n                axisLabel = createLabel(textPos, axisLabel, axisColor);\n                this.latticeParameters.add(axisLabel);\n                this.axisLabels.push(axisLabel);\n            }\n            else if (nPeriod === 2) {\n                let axisLabelObj = createLabel(textPos, axisLabel, axisColor);\n                this.latticeParameters.add(axisLabelObj);\n                this.axisLabels.push(axisLabelObj);\n                angleLabel = \"γ\";\n            }\n            else {\n                let axisText = \"a\";\n                let axisLabelObj = createLabel(textPos, axisText, axisColor);\n                this.latticeParameters.add(axisLabelObj);\n                this.axisLabels.push(axisLabelObj);\n            }\n            // Add basis vector colored line\n            let cellVectorMaterial = new THREE.MeshBasicMaterial({\n                color: axisColor,\n                transparent: true,\n                opacity: 0.75\n            });\n            let cellVector = basisVec1.clone();\n            let cellVectorLine = this.createCylinder(origin.clone(), cellVector.clone().add(origin), 0.09, 10, cellVectorMaterial);\n            this.latticeParameters.add(cellVectorLine);\n            // Add basis vector axis line\n            let cellAxisMaterial = new THREE.MeshBasicMaterial({\n                color: \"#000000\",\n            });\n            let axisStart = this.basisVectors[iTrueBasis].clone();\n            let axisEnd = axisStart.clone().multiplyScalar(1 + axisOffset / axisStart.length());\n            let cellAxisVector = basisVec1.clone();\n            let cellAxisVectorLine = this.createCylinder(origin.clone(), axisEnd, 0.02, 10, cellAxisMaterial);\n            this.latticeParameters.add(cellAxisVectorLine);\n            // Add axis arrow\n            let arrowGeometry = new THREE.CylinderGeometry(0, 0.10, 0.5, 12);\n            let arrowMaterial = new THREE.MeshBasicMaterial({\n                color: infoColor,\n            });\n            let arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);\n            arrow.position.copy(dir)\n                .multiplyScalar(1 + axisOffset / dir.length());\n            arrow.lookAt(new THREE.Vector3());\n            arrow.rotateX(-Math.PI / 2);\n            this.latticeParameters.add(arrow);\n            // Add angle label and curve\n            if (nPeriod === 1) {\n                continue;\n            }\n            else if (nPeriod === 2) {\n                if (!(iTrueBasis == first && (iTrueBasis + 1) % 3 == second)) {\n                    continue;\n                }\n            }\n            let arcMaterial = new THREE.LineDashedMaterial({\n                color: infoColor,\n                linewidth: 2,\n                dashSize: 0.2,\n                gapSize: 0.1\n            });\n            let normal = new THREE.Vector3().crossVectors(basisVec1, basisVec2);\n            let angle = basisVec1.angleTo(basisVec2);\n            let radius = Math.max(Math.min(1 / 4 * basisVec1.length(), 1 / 4 * basisVec2.length()), 1);\n            let curve = new THREE.EllipseCurve(0, 0, // ax, aY\n            radius, radius, // xRadius, yRadius\n            0, angle, // aStartAngle, aEndAngle\n            false // aClockwise\n            );\n            let points = curve.getSpacedPoints(20);\n            let arcGeometry = new THREE.Geometry().setFromPoints(points);\n            let arc = new THREE.Line(arcGeometry, arcMaterial);\n            arc.computeLineDistances();\n            // First rotate the arc so that it's x-axis points towards the\n            // first basis vector that defines the arc\n            let yAxis = new THREE.Vector3(0, 1, 0);\n            let xAxis = new THREE.Vector3(1, 0, 0);\n            let zAxis = new THREE.Vector3(0, 0, 1);\n            let quaternion = new THREE.Quaternion().setFromUnitVectors(xAxis, basisVec1.clone().normalize());\n            arc.quaternion.copy(quaternion);\n            // Then rotate the arc along it's x axis so that the xy-plane\n            // coincides with the plane defined by the the two basis vectors\n            // that define the plane.\n            let lastArcPointLocal = arcGeometry.vertices[arcGeometry.vertices.length - 1];\n            arc.updateMatrixWorld(); // The positions are not otherwise updated properly\n            let lastArcPointWorld = arc.localToWorld(lastArcPointLocal.clone());\n            // The angle direction is defined by the first basis vector\n            let axis = basisVec1;\n            let arcNormal = new THREE.Vector3()\n                .crossVectors(axis, lastArcPointWorld);\n            let planeAngle = normal.angleTo(arcNormal);\n            let planeCross = new THREE.Vector3()\n                .crossVectors(basisVec2, lastArcPointWorld);\n            let directionValue = planeCross.dot(axis);\n            if (directionValue > 0) {\n                planeAngle = -planeAngle;\n            }\n            arc.rotateX(planeAngle);\n            // Add label\n            arc.updateMatrixWorld(); // The positions are not otherwise updated properly\n            arc.updateMatrix(); // The positions are not otherwise updated properly\n            let angleLabelPos = arc.localToWorld(arcGeometry.vertices[9].clone());\n            let angleLabelLen = angleLabelPos.length();\n            angleLabelPos.multiplyScalar(1 + 0.3 / angleLabelLen);\n            let angleLabelObj = createLabel(angleLabelPos, angleLabel.toString(), \"#FFFFFF\", true);\n            this.latticeParameters.add(angleLabelObj);\n            this.axisLabels.push(angleLabelObj);\n            this.angleArcs.add(arc);\n        }\n    }\n    /**\n     * Creates a list of THREE.Vector3s from the given list of arrays.\n     *\n     * @param vectors - The positions from which to create vectors.\n     */\n    createBasisVectors(vectors) {\n        let result = [];\n        for (let len = vectors.length, i = 0; i < len; ++i) {\n            let vector = vectors[i];\n            let basis_vector = new THREE.Vector3().fromArray(vector);\n            result.push(basis_vector);\n        }\n        return result;\n    }\n    createVisualizationBoundaryPositions(positions, atomicNumbers) {\n        // Determine the maximum and minimum values in all cartesian components\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        let maxZ = -Infinity;\n        let minX = Infinity;\n        let minY = Infinity;\n        let minZ = Infinity;\n        let maxRadii = 0;\n        for (let len = positions.length, i = 0; i < len; ++i) {\n            let iPos = positions[i];\n            let iX = iPos.x;\n            if (iX > maxX) {\n                maxX = iX;\n            }\n            if (iX < minX) {\n                minX = iX;\n            }\n            let iY = iPos.y;\n            if (iY > maxY) {\n                maxY = iY;\n            }\n            if (iY < minY) {\n                minY = iY;\n            }\n            let iZ = iPos.z;\n            if (iZ > maxZ) {\n                maxZ = iZ;\n            }\n            if (iZ < minZ) {\n                minZ = iZ;\n            }\n            // Determine maximum radius that will be added to the visualization boundaries\n            let iRadius = this.elementRadii[atomicNumbers[i]];\n            if (iRadius > maxRadii) {\n                maxRadii = iRadius;\n            }\n        }\n        // Add max atomic radii to boundaries\n        // Push the corners of the cuboid as cornerpoints\n        let origin = new THREE.Vector3(minX - maxRadii, minY - maxRadii, minZ - maxRadii);\n        let basisX = new THREE.Vector3(maxX - minX + 2 * maxRadii, 0, 0);\n        let basisY = new THREE.Vector3(0, maxY - minY + 2 * maxRadii, 0);\n        let basisZ = new THREE.Vector3(0, 0, maxZ - minZ + 2 * maxRadii);\n        let basis = [basisX, basisY, basisZ];\n        // Get cuboid\n        let pointGeometry = this.createCornerPoints(origin, basis);\n        let points = new THREE.Points(pointGeometry);\n        points.visible = false;\n        this.cornerPoints = points;\n        // Must add the point to root because otherwise they will not be\n        // included in the transforms.\n        this.root.add(this.cornerPoints);\n    }\n    createVisualizationBoundaryCell(origin, basis) {\n        // Get cuboid\n        let pointGeometry = this.createCornerPoints(origin, basis);\n        let points = new THREE.Points(pointGeometry);\n        points.visible = false;\n        this.cornerPoints = points;\n        // Must add the point to root because otherwise they will not be\n        // included in the transforms.\n        this.root.add(this.cornerPoints);\n    }\n    /**\n     * Create the conventional cell\n     *\n     */\n    createConventionalCell(periodicity, visible) {\n        let cell = this.createCell(new THREE.Vector3(), this.basisVectors, periodicity, 0x000000, 1.5, false);\n        cell.visible = visible;\n        this.convCell = cell;\n        this.root.add(this.convCell);\n    }\n    /**\n     * Create the primitive cell\n     *\n     */\n    createPrimitiveCell(periodicity, visible) {\n        if (this.primitiveVectors != null) {\n            let cell = this.createCell(new THREE.Vector3(), this.primitiveVectors, periodicity, 0x000000, 1.5, true);\n            cell.visible = visible;\n            this.primCell = cell;\n            this.root.add(this.primCell);\n        }\n    }\n    /**\n     * Creates outlines for a cell specified by the given basis vectors.\n     * @param origin - The origin for the cell\n     * @param basisVectors - The cell basis vectors\n     * @param periodicity - The periodicity of the cell\n     * @param color - Color fo the cell wireframe\n     * @param linewidth - Line width fo the wireframe\n     * @param dashed - Is wireframe dashed\n     */\n    createCell(origin, basisVectors, periodicity, color, linewidth, dashed) {\n        let cell = new THREE.Object3D();\n        let lineMaterial;\n        if (dashed) {\n            lineMaterial = new THREE.LineDashedMaterial({\n                color: color,\n                linewidth: linewidth,\n                dashSize: 0.1,\n                gapSize: 0.1\n            });\n        }\n        else {\n            lineMaterial = new THREE.LineBasicMaterial({\n                color: color,\n                linewidth: linewidth\n            });\n        }\n        let dimMaterial = new THREE.LineDashedMaterial({\n            color: \"#999999\",\n            linewidth: linewidth,\n            dashSize: 0.1,\n            gapSize: 0.1\n        });\n        // Determine the if one of the cell vectors is a zero vector\n        let collapsed = true;\n        for (let i = 0; i < 3; ++i) {\n            let vec = basisVectors[i];\n            let len = vec.length();\n            if (len > 1E-3 && !periodicity[i]) {\n                collapsed = false;\n            }\n        }\n        for (let len = basisVectors.length, i = 0; i < len; ++i) {\n            let basisVector = basisVectors[i].clone();\n            // First line\n            let line1Mat = lineMaterial.clone();\n            let isDim1 = !periodicity[i];\n            if (!(isDim1 && collapsed)) {\n                if (isDim1) {\n                    line1Mat = dimMaterial.clone();\n                }\n                let lineGeometry = new THREE.Geometry();\n                lineGeometry.vertices.push(origin.clone(), basisVector.clone().add(origin));\n                let line = new THREE.Line(lineGeometry, line1Mat);\n                cell.add(line);\n                line.computeLineDistances();\n            }\n            // Second line\n            let secondIndex = (i + 1) % len;\n            let secondAddition = basisVectors[secondIndex].clone();\n            let isDim2 = !periodicity[i] || !periodicity[(i + 1) % 3];\n            if (!(isDim2 && collapsed)) {\n                let line2Mat = lineMaterial.clone();\n                if (isDim2) {\n                    line2Mat = dimMaterial.clone();\n                }\n                let line2Geometry = new THREE.Geometry();\n                line2Geometry.vertices.push(secondAddition.clone().add(origin), basisVector.clone().add(secondAddition).add(origin));\n                let line2 = new THREE.Line(line2Geometry, line2Mat);\n                cell.add(line2);\n                line2.computeLineDistances();\n            }\n            // Third line\n            let thirdIndex = (i + 2) % len;\n            let thirdAddition = basisVectors[thirdIndex].clone();\n            let isDim3 = !periodicity[i] || !periodicity[(i + 2) % 3];\n            if (!(isDim3 && collapsed)) {\n                let line3Mat = lineMaterial.clone();\n                if (isDim3) {\n                    line3Mat = dimMaterial.clone();\n                }\n                let line3Geometry = new THREE.Geometry();\n                line3Geometry.vertices.push(thirdAddition.clone().add(origin), basisVector.clone().add(thirdAddition).add(origin));\n                let line3 = new THREE.Line(line3Geometry, line3Mat);\n                cell.add(line3);\n                line3.computeLineDistances();\n            }\n            // Fourth line\n            let isDim4 = !periodicity[i] || !periodicity[(i + 2) % 3] || !periodicity[(i + 1) % 3];\n            if (!(isDim4 && collapsed)) {\n                let line4Mat = lineMaterial.clone();\n                if (isDim4) {\n                    line4Mat = dimMaterial.clone();\n                }\n                let line4Geometry = new THREE.Geometry();\n                line4Geometry.vertices.push(secondAddition.clone().add(thirdAddition).add(origin), basisVector.clone().add(secondAddition).add(thirdAddition).add(origin));\n                let line4 = new THREE.Line(line4Geometry, line4Mat);\n                cell.add(line4);\n                line4.computeLineDistances();\n            }\n        }\n        return cell;\n    }\n    /**\n     * Setups the initial view so that the scene is centered and rotated\n     * slightly to emphasize 3D nature.\n     */\n    setupInitialView1D(periodicity) {\n        // Rotate so that the chosen axis points to top\n        this.root.updateMatrixWorld(); // The positions are not otherwise updated properly\n        let startAxis;\n        for (let iAxis = 0; iAxis < periodicity.length; ++iAxis) {\n            let periodic = periodicity[iAxis];\n            if (periodic) {\n                startAxis = this.basisVectors[iAxis];\n            }\n        }\n        let finalAxis = new THREE.Vector3(1, 0, 0);\n        let segmentQ = new THREE.Quaternion().setFromUnitVectors(finalAxis, startAxis.clone().normalize());\n        segmentQ.conjugate();\n        this.root.quaternion.premultiply(segmentQ);\n        this.sceneInfo.quaternion.premultiply(segmentQ);\n        // Get the camera up and right directions in world space\n        let cameraUp = new THREE.Vector3(0, 1, 0);\n        let cameraRight = new THREE.Vector3(1, 0, 0);\n        cameraRight.applyQuaternion(this.camera.quaternion);\n        cameraUp.applyQuaternion(this.camera.quaternion);\n        // Rotate around the camera up-axis\n        let upAngle = Math.PI / 4;\n        this.rotateAroundWorldAxis(this.root, cameraUp, upAngle);\n        this.rotateAroundWorldAxis(this.sceneInfo, cameraUp, upAngle);\n        // Rotate around the camera right-axis\n        let rightAngle = Math.PI / 9;\n        this.rotateAroundWorldAxis(this.root, cameraRight, rightAngle);\n        this.rotateAroundWorldAxis(this.sceneInfo, cameraRight, rightAngle);\n    }\n    /**\n     * Setups the initial view so that the scene is centered and rotated\n     * slightly to emphasize 3D nature.\n     */\n    setupInitialView2D(periodicity, periodicIndices) {\n        let a = this.basisVectors[periodicIndices[0]].clone();\n        let c = [1, 1, 1];\n        for (let i = 0; i < periodicIndices.length; ++i) {\n            let periodic = periodicIndices[i];\n            c[periodic] = 0;\n        }\n        c = new THREE.Vector3().fromArray(c);\n        // Rotate so that the chosen axis points to top\n        this.root.updateMatrixWorld(); // The positions are not otherwise updated properly\n        let finalAxis = new THREE.Vector3(0, 0, 1);\n        let segmentQ = new THREE.Quaternion().setFromUnitVectors(c.clone().normalize(), finalAxis);\n        this.root.quaternion.premultiply(segmentQ);\n        this.sceneInfo.quaternion.premultiply(segmentQ);\n        a = a.clone().applyQuaternion(segmentQ);\n        c = c.clone().applyQuaternion(segmentQ);\n        // Rotate so that a points to the right\n        finalAxis = new THREE.Vector3(1, 0, 0);\n        segmentQ = new THREE.Quaternion().setFromUnitVectors(a.clone().normalize(), finalAxis);\n        this.root.quaternion.premultiply(segmentQ);\n        this.sceneInfo.quaternion.premultiply(segmentQ);\n        // The positions are not otherwise updated properly\n        this.root.updateMatrixWorld();\n        this.sceneInfo.updateMatrixWorld();\n        // Tilt the system slightly\n        let cameraRight = new THREE.Vector3(1, 0, 0);\n        cameraRight.applyQuaternion(this.camera.quaternion);\n        let rightAngle = -Math.PI / 6;\n        this.rotateAroundWorldAxis(this.root, cameraRight, rightAngle);\n        this.rotateAroundWorldAxis(this.sceneInfo, cameraRight, rightAngle);\n    }\n    /**\n     * Setups the initial view so that the scene is centered and rotated\n     * slightly to emphasize 3D nature.\n     */\n    setupInitialView3D() {\n        let a = this.basisVectors[0];\n        let b = this.basisVectors[1];\n        let c = this.basisVectors[2];\n        // Rotate so that the c-axis points to top\n        this.root.updateMatrixWorld(); // The positions are not otherwise updated properly\n        let finalCAxis = new THREE.Vector3(0, 1, 0);\n        let cQuaternion = new THREE.Quaternion().setFromUnitVectors(c.clone().normalize(), finalCAxis);\n        this.root.quaternion.premultiply(cQuaternion);\n        this.sceneInfo.quaternion.premultiply(cQuaternion);\n        this.root.updateMatrixWorld();\n        this.sceneInfo.updateMatrixWorld();\n        b = b.clone().applyQuaternion(cQuaternion);\n        c = c.clone().applyQuaternion(cQuaternion);\n        // Rotate so that c x b points to the right\n        let currentAAxis = new THREE.Vector3().crossVectors(b, c);\n        let finalAAxis = new THREE.Vector3(0, 0, 1);\n        let aQuaternion = new THREE.Quaternion().setFromUnitVectors(currentAAxis.clone().normalize(), finalAAxis);\n        this.root.quaternion.premultiply(aQuaternion);\n        this.sceneInfo.quaternion.premultiply(aQuaternion);\n        this.root.updateMatrixWorld();\n        this.sceneInfo.updateMatrixWorld();\n        b = b.clone().applyQuaternion(aQuaternion);\n        c = c.clone().applyQuaternion(aQuaternion);\n        let cameraVector = new THREE.Vector3(0, 0, -1);\n        cameraVector.applyQuaternion(this.camera.quaternion);\n        // Rotate around the c-axis\n        let tiltAxis2 = new THREE.Vector3().crossVectors(cameraVector, b);\n        tiltAxis2.normalize();\n        let tiltAngle2 = -Math.PI / 3;\n        //let tiltAngle2 = -Math.PI/6;\n        this.rotateAroundWorldAxis(this.root, tiltAxis2, tiltAngle2);\n        this.rotateAroundWorldAxis(this.sceneInfo, tiltAxis2, tiltAngle2);\n        // Rotate around the axis defined by the cross-product of the\n        // cameraVector and basis vector c\n        let tiltAxis = new THREE.Vector3().crossVectors(cameraVector, c);\n        tiltAxis.normalize();\n        let tiltAngle = Math.PI / 6;\n        //let tiltAngle = Math.PI/12;\n        this.rotateAroundWorldAxis(this.root, tiltAxis, tiltAngle);\n        this.rotateAroundWorldAxis(this.sceneInfo, tiltAxis, tiltAngle);\n    }\n    /**\n     * Creates representation for all the given atoms.\n     *\n     * @param positions - Positions of the atoms\n     * @param labels - The element numbers for the atoms\n     */\n    createAtoms(relPositions, labels, duplicate) {\n        this.elements = {};\n        this.atomPos = [];\n        this.atomNumbers = [];\n        this.atomFills = [];\n        this.atomOutlines = [];\n        let basis1 = this.basisVectors[0];\n        let basis2 = this.basisVectors[1];\n        let basis3 = this.basisVectors[2];\n        let meshMap = {};\n        for (let len = relPositions.length, i = 0; i < len; ++i) {\n            let iRelPos = relPositions[i];\n            // Add the primary atom\n            let atomicNumber = labels[i];\n            this.addAtom(i, iRelPos, atomicNumber, meshMap);\n            // Gather element legend data\n            let elementName = this.elementNames[atomicNumber - 1];\n            this.elements[elementName] = [this.elementColors[atomicNumber], this.elementRadii[atomicNumber]];\n            // If the atom sits on the cell surface, add the mirror images if\n            // requested.\n            if (duplicate) {\n                let x = iRelPos.x;\n                let y = iRelPos.y;\n                let z = iRelPos.z;\n                let xZero = this.almostEqual(0, x, basis1, this.wrapTolerance);\n                let yZero = this.almostEqual(0, y, basis2, this.wrapTolerance);\n                let zZero = this.almostEqual(0, z, basis3, this.wrapTolerance);\n                ;\n                if (xZero && yZero && zZero) {\n                    this.addAtom(i, new THREE.Vector3(1, 0, 0), atomicNumber, meshMap);\n                    this.addAtom(i, new THREE.Vector3(0, 1, 0), atomicNumber, meshMap);\n                    this.addAtom(i, new THREE.Vector3(0, 0, 1), atomicNumber, meshMap);\n                    this.addAtom(i, new THREE.Vector3(1, 1, 0), atomicNumber, meshMap);\n                    this.addAtom(i, new THREE.Vector3(0, 1, 1), atomicNumber, meshMap);\n                    this.addAtom(i, new THREE.Vector3(1, 0, 1), atomicNumber, meshMap);\n                    this.addAtom(i, new THREE.Vector3(1, 1, 1), atomicNumber, meshMap);\n                }\n                else if (xZero && yZero && !zZero) {\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(1, 0, 0)), atomicNumber, meshMap);\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 1, 0)), atomicNumber, meshMap);\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(1, 1, 0)), atomicNumber, meshMap);\n                }\n                else if (!xZero && yZero && zZero) {\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 1, 0)), atomicNumber, meshMap);\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 0, 1)), atomicNumber, meshMap);\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 1, 1)), atomicNumber, meshMap);\n                }\n                else if (xZero && !yZero && zZero) {\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(1, 0, 0)), atomicNumber, meshMap);\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 0, 1)), atomicNumber, meshMap);\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(1, 0, 1)), atomicNumber, meshMap);\n                }\n                else if (xZero && !yZero && !zZero) {\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(1, 0, 0)), atomicNumber, meshMap);\n                }\n                else if (!xZero && yZero && !zZero) {\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 1, 0)), atomicNumber, meshMap);\n                }\n                else if (!xZero && !yZero && zZero) {\n                    this.addAtom(i, iRelPos.clone().add(new THREE.Vector3(0, 0, 1)), atomicNumber, meshMap);\n                }\n            }\n        }\n    }\n    /**\n     * Creates bonds between the atoms based on radii and distance.\n     *\n     * @param bonds - A Nx2 list of atom indices specifying the bonded atoms. Alternatively\n     *                you can use \"auto\" to automatically create the bonds.\n     */\n    createBonds(bonds = \"auto\") {\n        this.bondFills = [];\n        // Manual bonds\n        if (Array.isArray(bonds)) {\n            for (let bond of bonds) {\n                let i = bond[0];\n                let j = bond[1];\n                let pos1 = this.atomPos[i];\n                let pos2 = this.atomPos[j];\n                console.log(i, j, pos1, pos2);\n                this.addBond(i, j, pos1, pos2);\n            }\n            // Automatically detect bonds\n        }\n        else if (bonds === \"auto\") {\n            let nAtoms = this.atomPos.length;\n            for (let i = 0; i < nAtoms; ++i) {\n                for (let j = 0; j < nAtoms; ++j) {\n                    if (j > i) {\n                        let pos1 = this.atomPos[i];\n                        let pos2 = this.atomPos[j];\n                        let num1 = this.atomNumbers[i];\n                        let num2 = this.atomNumbers[j];\n                        let distance = pos2.clone().sub(pos1).length();\n                        let radii1 = this.options.structure.radiusScale * this.elementRadii[num1];\n                        let radii2 = this.options.structure.radiusScale * this.elementRadii[num2];\n                        if (distance <= this.options.structure.bondScale * 1.1 * (radii1 + radii2)) {\n                            this.addBond(i, j, pos1, pos2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Used to check if the given relative position component is almost the\n     * given target value with a tolerance given in cartesian corodinates.\n     */\n    almostEqual(target, coordinate, basisVector, tolerance) {\n        let relDistance = (coordinate - target);\n        let absDistance = Math.abs(basisVector.clone().multiplyScalar(relDistance).length());\n        if (absDistance < tolerance) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Creates atom to the scene.\n     *\n     * @param position - Position of the atom\n     * @param atomicNumber - The atomic number for the added atom\n     * @param relative - Are the coordinates relatice to the cell basis vectors\n     */\n    addBond(i, j, pos1, pos2) {\n        // Bond\n        let radius = 0.08;\n        let bondMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, shininess: 30 });\n        let cylinder = this.createCylinder(pos1, pos2, radius, 10, bondMaterial);\n        cylinder.name = \"fill\";\n        this.bondFills.push(cylinder);\n        // Bond outline hack\n        let addition = 0.02;\n        let scale = addition / radius + 1;\n        let outlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });\n        let outline = this.createCylinder(pos1, pos2, scale * radius, 10, outlineMaterial);\n        outline.name = \"outline\";\n        // Put all vonds visuals inside a named group\n        let group = new THREE.Group();\n        group.name = \"bond\" + i + \"-\" + j;\n        group.add(cylinder);\n        group.add(outline);\n        this.bonds.add(group);\n    }\n    /**\n     * Creates atoms.\n     *\n     * @param position - Position of the atom\n     * @param atomicNumber - The atomic number for the added atom\n     * @param relative - Are the coordinates relatice to the cell basis vectors\n     */\n    createAtom(position, atomicNumber, meshMap, relative = true) {\n        let exists = atomicNumber in meshMap;\n        if (!exists) {\n            // Calculate the amount of segments that are needed to reach a\n            // certain angle for the ball surface segements\n            let radius = this.options.structure.radiusScale * this.elementRadii[atomicNumber];\n            let targetAngle = 165;\n            let nSegments = Math.ceil(360 / (180 - targetAngle));\n            // Atom\n            let color = this.elementColors[atomicNumber];\n            let atomGeometry = new THREE.SphereGeometry(radius, nSegments, nSegments);\n            let atomMaterial = new THREE.MeshPhongMaterial({ color: color, shininess: 30 });\n            let atom = new THREE.Mesh(atomGeometry, atomMaterial);\n            // Atom outline hack\n            let addition = 0.03;\n            let scale = addition / radius + 1;\n            let outlineGeometry = new THREE.SphereGeometry(radius * scale, nSegments, nSegments);\n            let outlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });\n            let outline = new THREE.Mesh(outlineGeometry, outlineMaterial);\n            meshMap[atomicNumber] = { \"atom\": atom, \"outline\": outline };\n        }\n        let mesh = meshMap[atomicNumber];\n        let true_pos = new THREE.Vector3();\n        if (relative) {\n            true_pos.add(this.basisVectors[0].clone().multiplyScalar(position.x));\n            true_pos.add(this.basisVectors[1].clone().multiplyScalar(position.y));\n            true_pos.add(this.basisVectors[2].clone().multiplyScalar(position.z));\n        }\n        else {\n            true_pos.copy(position);\n        }\n        // Add atom\n        let atom = mesh[\"atom\"].clone();\n        atom.position.copy(true_pos);\n        // Add atom outline\n        let outline = mesh[\"outline\"].clone();\n        outline.position.copy(true_pos);\n        return [atom, outline, true_pos];\n    }\n    /**\n     * Creates atoms and directly adds themto the scene.\n     *\n     * @param position - Position of the atom\n     * @param atomicNumber - The atomic number for the added atom\n     * @param relative - Are the coordinates relatice to the cell basis vectors\n     */\n    addAtom(index, position, atomicNumber, mesh, relative = true) {\n        let atomData = this.createAtom(position, atomicNumber, mesh, relative);\n        let atom = atomData[0];\n        let outline = atomData[1];\n        let pos = atomData[2];\n        // Put all atoms visuals inside a named group\n        let group = new THREE.Group();\n        group.name = \"atom\" + index;\n        atom.name = \"fill\";\n        outline.name = \"outline\";\n        group.add(atom);\n        group.add(outline);\n        this.atoms.add(group);\n        this.atomFills.push(atom);\n        this.atomOutlines.push(outline);\n        this.atomPos.push(pos);\n        this.atomNumbers.push(atomicNumber);\n    }\n    /*\n     * A modified render-function that scales the labels according to the zoom\n     * level.\n     */\n    render() {\n        let canvas = this.rootElement;\n        let canvasWidth = canvas.clientWidth;\n        let canvasHeight = canvas.clientHeight;\n        // Project a [1,0,0] vector in the camera space to the world space, and\n        // then to the screen space. The length of this vector is then used to\n        // scale the labels.\n        let x = new THREE.Vector3(1, 0, 0);\n        let origin = new THREE.Vector3(0, 0, 0);\n        let vectors = [x, origin];\n        for (let i = 0; i < vectors.length; ++i) {\n            let vec = vectors[i];\n            this.camera.localToWorld(vec);\n            vec.project(this.camera);\n            vec.x = Math.round((vec.x + 1) * canvasWidth / 2);\n            vec.y = Math.round((-vec.y + 1) * canvasHeight / 2);\n        }\n        let displacement = new THREE.Vector3().subVectors(origin, x);\n        let distance = displacement.length();\n        let scale = 8 * 1 / Math.pow(distance, 0.5); // The sqrt makes the scaling behave nicer...\n        if (this.axisLabels !== undefined) {\n            for (let i = 0; i < this.axisLabels.length; ++i) {\n                let label = this.axisLabels[i];\n                label.scale.set(scale, scale, 1);\n            }\n        }\n        super.render();\n    }\n    /**\n     * Setup the view for 0D systems (atoms, molecules).\n     */\n    setup0D(relPos, cartPos, labels) {\n        this.createConventionalCell([false, false, false], this.options.structure.showCell);\n        this.createPrimitiveCell([false, false, false], this.options.structure.showCell);\n        this.createAtoms(relPos, labels, false);\n        this.createLatticeParameters(this.basisVectors, [false, false, false]);\n    }\n    /**\n     * Replicates the structure along the specified direction to emphasize the\n     * 1D nature of the material.\n     *\n     * @param dim - The index of the periodic dimension.\n     */\n    setup1D(relPos, cartPos, labels, periodicity, periodicIndices) {\n        let dim = periodicIndices[0];\n        let trans = new THREE.Vector3();\n        trans.setComponent(dim, 1);\n        // Duplicate the cell in the periodic dimensions. The number of\n        // duplications is determined so that a certain size is achieved.\n        let translation1 = this.basisVectors[dim].clone();\n        let multiplier = this.getRepetitions(translation1, 15);\n        // Multiply the structure in the periodic dimension\n        let newPos = [];\n        let newLabels = [];\n        for (let i = 1; i <= multiplier; ++i) {\n            // Add in front\n            let frontTranslation = trans.clone().multiplyScalar(i);\n            for (let k = 0; k < relPos.length; ++k) {\n                let iPos = new THREE.Vector3().copy(relPos[k]);\n                iPos.add(frontTranslation);\n                let iLabel = labels[k];\n                newPos.push(iPos);\n                newLabels.push(iLabel);\n            }\n            // Add in front\n            let backTranslation = trans.clone().multiplyScalar(-i);\n            for (let k = 0; k < relPos.length; ++k) {\n                let iPos = new THREE.Vector3().copy(relPos[k]);\n                iPos.add(backTranslation);\n                let iLabel = labels[k];\n                newPos.push(iPos);\n                newLabels.push(iLabel);\n            }\n        }\n        relPos.push.apply(relPos, newPos);\n        labels.push.apply(labels, newLabels);\n        if (this.options.structure.showCell) {\n            this.createConventionalCell(periodicity);\n            this.createPrimitiveCell(periodicity);\n        }\n        this.createAtoms(relPos, labels, false);\n        this.createLatticeParameters(this.basisVectors, periodicity);\n        this.setupInitialView1D(periodicity);\n    }\n    /**\n     * Used to get a number of repetitions that are needed for the given\n     * latticevector to reach the target size.\n     *\n     * @param latticeVector - The vector that is to be extended.\n     * @param targetSize - The targeted size.\n     */\n    getRepetitions(latticeVector, targetSize) {\n        let vectorLen = latticeVector.length();\n        let multiplier = Math.max(Math.floor(targetSize / vectorLen) - 1, 1);\n        return multiplier;\n    }\n    /**\n     * Replicates the structure along the specified direction to emphasize the\n     * 2D nature of the material.\n     *\n     * @param periodicIndices - The indices of the periodic dimension.\n     */\n    setup2D(relPos, cartPos, labels, periodicity, periodicIndices) {\n        let dim1 = periodicIndices[0];\n        let dim2 = periodicIndices[1];\n        let relTrans1 = new THREE.Vector3();\n        relTrans1.setComponent(dim1, 1);\n        let relTrans2 = new THREE.Vector3();\n        relTrans2.setComponent(dim2, 1);\n        // Duplicate the cell in the periodic dimensions. The number of\n        // duplications is determined so that a certain size is achieved.\n        let translation1 = this.basisVectors[dim1].clone();\n        let translation2 = this.basisVectors[dim2].clone();\n        let width = 0;\n        let height = 0;\n        if (this.options.structure.allowRepeat) {\n            width = this.getRepetitions(translation1, 12);\n            height = this.getRepetitions(translation2, 12);\n        }\n        let newPos = [];\n        let newLabels = [];\n        for (let i = 0; i <= width; ++i) {\n            for (let j = 0; j <= height; ++j) {\n                if (!(i == 0 && j == 0)) {\n                    // Add clone to the current coordinate\n                    let xTranslation = relTrans1.clone().multiplyScalar(i);\n                    let yTranslation = relTrans2.clone().multiplyScalar(j);\n                    // Add in front\n                    //let frontTranslation = trans.clone().multiplyScalar(i)\n                    for (let k = 0; k < relPos.length; ++k) {\n                        let iPos = new THREE.Vector3().copy(relPos[k]);\n                        iPos.add(xTranslation);\n                        iPos.add(yTranslation);\n                        let iLabel = labels[k];\n                        newPos.push(iPos);\n                        newLabels.push(iLabel);\n                    }\n                }\n            }\n        }\n        relPos.push.apply(relPos, newPos);\n        labels.push.apply(labels, newLabels);\n        this.createConventionalCell(periodicity, this.options.structure.showCell);\n        this.createPrimitiveCell(periodicity, this.options.structure.showCell);\n        this.createAtoms(relPos, labels, false);\n        this.createLatticeParameters(this.basisVectors, periodicity, periodicIndices);\n        this.setupInitialView2D(periodicity, periodicIndices);\n    }\n    /**\n     * Setup the view for 3D systems (crystals)\n     */\n    setup3D(relPos, cartPos, labels) {\n        this.createConventionalCell([true, true, true], this.options.structure.showCell);\n        this.createPrimitiveCell([true, true, true], this.options.structure.showCell);\n        this.createAtoms(relPos, labels, this.options.structure.showCopies);\n        this.createLatticeParameters(this.basisVectors, [true, true, true]);\n        this.setupInitialView3D();\n    }\n}\n\n\n//# sourceURL=webpack://matviewer/./src/js/structureviewer.js?");

/***/ }),

/***/ "./src/js/viewer.js":
/*!**************************!*\
  !*** ./src/js/viewer.js ***!
  \**************************/
/*! exports provided: Viewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewer\", function() { return Viewer; });\n/* harmony import */ var _orthographiccontrols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./orthographiccontrols */ \"./src/js/orthographiccontrols.js\");\n\n/**\n * Abstract base class for visualizing 3D scenes with three.js.\n */\nclass Viewer {\n    /**\n     * @param {html element} hostElement is the html element where the\n     *     visualization canvas will be appended.\n     * @param {boolean} saveBuffer boolean is used to indicate if the screenbuffer\n     *     should be stored for creating screenshots. When not creating\n     *     screenshots keep it off.\n     * @param {options} An object that can hold custom settings for the viewer.\n     */\n    constructor(hostElement, options = {}, saveBuffer = false) {\n        this.hostElement = hostElement;\n        this.saveBuffer = saveBuffer;\n        this.scenes = []; // A list of scenes that are rendered\n        this.cameraWidth = 10.0; // The default \"width\" of the camera\n        this.options = {}; // Options for the viewer. Can be e.g. used to control which settings are enabled\n        this.handleSettings(options);\n        this.setupRootElement();\n        this.setupRenderer();\n        this.setupScenes();\n        this.setupStatic();\n        this.setupCamera();\n        this.setupControls();\n        this.setupHostElement(hostElement);\n        if (this.options.view.autoResize) {\n            window.addEventListener('resize', this.onWindowResize.bind(this), false);\n        }\n    }\n    handleSettings(opt) {\n        // The default settings object\n        let options = {\n            controls: {\n                enableZoom: true,\n                enableRotate: true,\n                enablePan: true,\n                panSpeed: 10,\n                zoomSpeed: 2.5,\n                rotateSpeed: 2.5,\n                zoomLevel: 1,\n            },\n            view: {\n                autoFit: true,\n                autoResize: true,\n                fitMargin: 0.5,\n            },\n            font: {\n                family: \"Arial\"\n            },\n        };\n        // Save custom settings\n        this.fillOptions(opt, options);\n        this.options = options;\n    }\n    /**\n     * Used to recursively fill the target options with options stored in the\n     * source object.\n     */\n    fillOptions(source, target) {\n        // Overrride with settings from user and child class\n        function eachRecursive(source, target, level) {\n            for (var k in source) {\n                // Find variable in default settings\n                if (typeof source[k] == \"object\" && source[k] !== null) {\n                    // If the current level is not defined in the target, it is\n                    // initialized with empty object.\n                    if (target[k] === undefined) {\n                        target[k] = {};\n                    }\n                    eachRecursive(source[k], target[k]);\n                }\n                else {\n                    // We store each leaf property into the default settings\n                    target[k] = source[k];\n                }\n            }\n        }\n        eachRecursive(source, target);\n    }\n    /**\n     * This function will clear the old view and visualize the new Brilloun\n     * zone based on the given data.\n     *\n     * @param {object} data object holding the visualized data.\n     */\n    load(data) {\n        // Clear all the old data\n        this.clear();\n        // Reconstruct the visualization\n        this.setupScenes();\n        this.setupLights();\n        this.setupCamera();\n        this.setupControls();\n        let valid = this.setupVisualization(data);\n        if (this.options.view.autoFit) {\n            this.fitToCanvas();\n        }\n        this.render();\n        return valid;\n    }\n    /**\n     * Loads visuzalization data from a JSON url.\n     *\n     * @param {string} url Path to the json resource.\n     */\n    loadJSON(url) {\n        // Open file\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            this.load(JSON.parse(xhr.responseText));\n        };\n        xhr.open(\"GET\", url, true);\n        xhr.send();\n    }\n    /**\n     * This function can be used to setup any static assets in the\n     * constructore, like dat.gui settings window.\n     */\n    setupStatic() {\n    }\n    /*\n     * Used to setup the scenes. This default implementation will create a\n     * single scene. Override this function to create additional scenes and\n     * push them all to the 'scenes' attribute.\n     */\n    setupScenes() {\n        this.scenes = [];\n        this.scene = new THREE.Scene();\n        this.scenes.push(this.scene);\n    }\n    /*\n     * Clears the entire visualization.\n     */\n    clear() {\n        this.clearScenes();\n        this.scenes = null;\n        this.controls = null;\n        this.camera = null;\n        this.cornerPoints = null;\n    }\n    /*\n     * This function will clear everything inside the scenes. This should\n     * ensure that memory is not leaked. Cameras, controls and lights are not\n     * part of the scene, so they are reset elsewhere.\n     */\n    clearScenes() {\n        for (let iScene = 0; iScene < this.scenes.length; ++iScene) {\n            let scene = this.scenes[iScene];\n            scene.traverse(function (node) {\n                let geometry = node.geometry;\n                let material = node.material;\n                let texture = node.texture;\n                if (geometry) {\n                    geometry.dispose();\n                }\n                if (material) {\n                    material.dispose();\n                }\n                if (texture) {\n                    texture.dispose();\n                }\n            });\n            while (scene.children.length) {\n                let child = scene.children[0];\n                scene.remove(child);\n            }\n        }\n    }\n    /**\n     * Can be used to download the current visualization as a jpg-image to the\n     * browser's download location.\n     */\n    takeScreenShot(filename) {\n        let imgData, imgNode;\n        try {\n            let strMime = \"image/jpeg\";\n            let strDownloadMime = \"image/octet-stream\";\n            imgData = this.renderer.domElement.toDataURL(strMime);\n            let strData = imgData.replace(strMime, strDownloadMime);\n            filename = filename + \".jpg\";\n            let link = document.createElement('a');\n            if (typeof link.download === 'string') {\n                document.body.appendChild(link); //Firefox requires the link to be in the body\n                link.download = filename;\n                link.href = strData;\n                link.click();\n                document.body.removeChild(link); //remove the link when done\n            }\n            else {\n                location.replace(uri);\n            }\n        }\n        catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n    /**\n     * This will check if WegGL is available on the current browser.\n     */\n    webglAvailable() {\n        try {\n            let canvas = document.createElement('canvas');\n            return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') ||\n                canvas.getContext('experimental-webgl')));\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * This will setup the three.js renderer object. Uses WebGL by default, can\n     * use a canvas fallback is WegGL is not available.\n     */\n    setupRenderer() {\n        // Create the renderer. The \"alpha: true\" enables to set a background color.\n        if (this.webglAvailable()) {\n            this.renderer = new THREE.WebGLRenderer({\n                alpha: true,\n                antialias: true,\n                preserveDrawingBuffer: this.saveBuffer\n            });\n        }\n        else {\n            console.log(\"WebGL is not supported on this browser, cannot display structure.\");\n        }\n        this.renderer.shadowMap.enabled = false;\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        this.renderer.setSize(this.rootElement.clientWidth, this.rootElement.clientHeight);\n        this.renderer.setClearColor(0xffffff, 0); // The clear color is set to fully transparent to support custom backgrounds\n        this.rootElement.appendChild(this.renderer.domElement);\n        // This is set so that multiple scenes can be used, see\n        // http://stackoverflow.com/questions/12666570/how-to-change-the-zorder-of-object-with-threejs/12666937#12666937\n        this.renderer.autoClear = false;\n    }\n    /*\n     * Used to setup and position the camera.\n     */\n    setupCamera() {\n        let aspectRatio = this.rootElement.clientWidth / this.rootElement.clientHeight;\n        let width = this.cameraWidth;\n        let height = width / aspectRatio;\n        this.camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -100, 1000);\n        this.camera.name = \"camera\";\n        this.camera.position.z = 20;\n    }\n    /**\n     * Used to setup a root DIV element that will contain the whole\n     * visualization, and which will be placed inside the given target element.\n     *\n     * The root element should always fill the whole host element, and we try\n     * to ensure this by setting width and height to 100%. The position is set\n     * to relative, so that the child divs can be set relative to this root div\n     * with absolute positioning.\n     */\n    setupRootElement() {\n        this.rootElement = document.createElement(\"div\");\n        this.rootElement.style.width = \"100%\";\n        this.rootElement.style.height = \"100%\";\n        this.rootElement.style.position = \"relative\";\n    }\n    /**\n     * Used to setup the DOM element where the viewer will be displayed.\n     */\n    setupHostElement(hostElement) {\n        // If a previous target element is set, remove it\n        if (this.hostElement) {\n            while (this.hostElement.firstChild) {\n                this.hostElement.removeChild(this.hostElement.firstChild);\n            }\n        }\n        // Setup the new targetElment\n        hostElement.appendChild(this.rootElement);\n        this.resizeCanvasToHostElement();\n    }\n    /**\n     * Used to setup the DOM element where the viewer will be displayed.\n     */\n    changeHostElement(hostElement) {\n        this.setupHostElement(hostElement);\n        if (this.options.view.autoFit) {\n            this.fitToCanvas();\n        }\n        this.render();\n    }\n    /*\n     * Used to setup the controls that allow interacting with the visualization\n     * with mouse.\n     */\n    setupControls() {\n        let controls = new _orthographiccontrols__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicControls\"](this.camera, this.rootElement);\n        controls.rotateSpeed = this.options.controls.rotateSpeed;\n        controls.rotationCenter = new THREE.Vector3();\n        controls.zoomSpeed = this.options.controls.zoomSpeed;\n        controls.panSpeed = this.options.controls.panSpeed;\n        controls.enableZoom = this.options.controls.enableZoom;\n        controls.enablePan = this.options.controls.enablePan;\n        controls.enableRotate = this.options.controls.enableRotate;\n        controls.staticMoving = true;\n        controls.dynamicDampingFactor = 0.25;\n        controls.keys = [65, 83, 68];\n        controls.addEventListener('change', this.render.bind(this));\n        this.controls = controls;\n    }\n    /**\n     * Creates 8 corner points for the given cuboid.\n     *\n     * @param origin - The origin of the cuboid.\n     * @param basis - The vectors that define the cuboid.\n     */\n    createCornerPoints(origin, basis) {\n        var geometry = new THREE.Geometry();\n        geometry.vertices.push(origin);\n        let opposite = origin.clone().add(basis[0]).add(basis[1]).add(basis[2]);\n        geometry.vertices.push(opposite);\n        for (let len = basis.length, i = 0; i < len; ++i) {\n            // Corners close to origin\n            let position1 = origin.clone().add(basis[i].clone());\n            geometry.vertices.push(position1);\n            // Corners close to opposite point of origin\n            let position2 = opposite.clone().sub(basis[i].clone());\n            geometry.vertices.push(position2);\n        }\n        return geometry;\n    }\n    /**\n     * This will automatically fit the structure to the given rendering area.\n     * Will also leave a small margin.\n     */\n    fitToCanvas() {\n        // Make sure that all transforms are updated\n        this.scenes.forEach((scene) => scene.updateMatrixWorld());\n        // Project all 8 corners of the normalized cell into screen space and\n        // see how the system should be scaled to fit it to screen\n        let canvas = this.rootElement;\n        let canvasWidth = canvas.clientWidth;\n        let canvasHeight = canvas.clientHeight;\n        let cornerPos = [];\n        // Figure out the center in order to add margins in right direction\n        let centerPos = new THREE.Vector3();\n        for (let len = this.cornerPoints.geometry.vertices.length, i = 0; i < len; ++i) {\n            let screenPos = this.cornerPoints.geometry.vertices[i].clone();\n            this.cornerPoints.localToWorld(screenPos);\n            centerPos.add(screenPos);\n        }\n        for (let len = this.cornerPoints.geometry.vertices.length, i = 0; i < len; ++i) {\n            let screenPos = this.cornerPoints.geometry.vertices[i].clone();\n            this.cornerPoints.localToWorld(screenPos);\n            // Default the zoom to 1 for the projection\n            let oldZoom = this.camera.zoom;\n            this.camera.zoom = this.options.controls.zoomLevel;\n            this.camera.updateProjectionMatrix();\n            // Figure out the direction from center\n            let diff = centerPos.sub(screenPos);\n            diff.project(this.camera);\n            let right = diff.x < 0 ? true : false;\n            let up = diff.y < 0 ? true : false;\n            // Map to corner coordinates to\n            screenPos.project(this.camera);\n            // Add a margin\n            let margin = this.options.view.fitMargin;\n            let cameraUp = new THREE.Vector3(0, margin, 0);\n            let cameraRight = new THREE.Vector3(margin, 0, 0);\n            cameraUp.applyQuaternion(this.camera.quaternion);\n            cameraRight.applyQuaternion(this.camera.quaternion);\n            if (up) {\n                screenPos.add(cameraUp);\n            }\n            else {\n                screenPos.sub(cameraUp);\n            }\n            if (right) {\n                screenPos.add(cameraRight);\n            }\n            else {\n                screenPos.sub(cameraRight);\n            }\n            // Map to 2D screen space\n            screenPos.x = Math.round((screenPos.x + 1) * canvasWidth / 2);\n            screenPos.y = Math.round((-screenPos.y + 1) * canvasHeight / 2);\n            screenPos.z = 0;\n            cornerPos.push(screenPos);\n        }\n        // Find the minimum and maximum in both screen dimensions\n        let minX = cornerPos[0].x;\n        let maxX = cornerPos[0].x;\n        let minY = cornerPos[0].y;\n        let maxY = cornerPos[0].y;\n        for (let len = cornerPos.length, i = 0; i < len; ++i) {\n            let pos = cornerPos[i];\n            let x = pos.x;\n            let y = pos.y;\n            if (x > maxX) {\n                maxX = x;\n            }\n            else if (x < minX) {\n                minX = x;\n            }\n            if (y > maxY) {\n                maxY = y;\n            }\n            else if (y < minY) {\n                minY = y;\n            }\n        }\n        // Calculate width margin by scaling the\n        let width = maxX - minX;\n        let height = maxY - minY;\n        let xFactor = canvasWidth / width;\n        let yFactor = canvasHeight / height;\n        // Decide which dimension is the more restricting one\n        let factor;\n        if (xFactor <= 1 && yFactor <= 1) {\n            factor = Math.min(xFactor, yFactor);\n        }\n        else if (xFactor >= 1 && yFactor >= 1) {\n            factor = Math.min(xFactor, yFactor);\n        }\n        else if (xFactor <= 1 && yFactor >= 1) {\n            factor = xFactor;\n        }\n        else if (yFactor <= 1 && xFactor >= 1) {\n            factor = yFactor;\n        }\n        this.camera.zoom = factor;\n        this.camera.updateProjectionMatrix();\n    }\n    /*\n     * Get the current zoom level for the visualization.\n     */\n    getZoom() {\n        return this.camera.zoom;\n    }\n    /**\n     * Sets the zoom level for the visualization.\n     *\n     * @param zoom - The wanted zoom level as a floating point number.\n     */\n    setZoom(zoom) {\n        this.camera.zoom = zoom;\n        this.camera.updateProjectionMatrix();\n    }\n    /*\n     * Callback function that is invoked when the window is resized.\n     */\n    resizeCanvasToHostElement() {\n        let aspectRatio = this.rootElement.clientWidth / this.rootElement.clientHeight;\n        let width = this.cameraWidth;\n        let height = width / aspectRatio;\n        this.camera.left = -width / 2;\n        this.camera.right = width / 2;\n        this.camera.top = height / 2;\n        this.camera.bottom = -height / 2;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(this.rootElement.clientWidth, this.rootElement.clientHeight);\n        this.controls.handleResize();\n        this.render();\n    }\n    onWindowResize() {\n        this.resizeCanvasToHostElement();\n        if (this.options.view.autoFit) {\n            this.fitToCanvas();\n        }\n        this.render();\n    }\n    /*\n     * Used to render all the scenes that are present. The scenes will be\n     * rendered on top of each other, so make sure that they are in the right\n     * order.\n     *\n     * This approach is copied from\n     * http://stackoverflow.com/questions/12666570/how-to-change-the-zorder-of-object-with-threejs/12666937#12666937\n     */\n    render() {\n        this.renderer.clear();\n        for (let iScene = 0; iScene < this.scenes.length; ++iScene) {\n            let scene = this.scenes[iScene];\n            this.renderer.render(scene, this.camera);\n            if (iScene !== this.scenes.length - 1) {\n                this.renderer.clearDepth();\n            }\n        }\n    }\n    /**\n     * Helper function for creating a cylinder mesh.\n     *\n     * @param pos1 - Start position\n     * @param pos2 - End position\n     * @param radius - Cylinder radius\n     * @param material - Cylinder material\n     */\n    createCylinder(pos1, pos2, radius, nSegments, material) {\n        var direction = new THREE.Vector3().subVectors(pos2, pos1);\n        let dirLen = direction.length();\n        let dirNorm = direction.clone().divideScalar(dirLen);\n        var arrow = new THREE.ArrowHelper(dirNorm, pos1);\n        var edgeGeometry = new THREE.CylinderGeometry(radius, radius, dirLen, nSegments, 0);\n        var edge = new THREE.Mesh(edgeGeometry, material);\n        edge.rotation.copy(arrow.rotation.clone());\n        edge.position.copy(new THREE.Vector3().addVectors(pos1, direction.multiplyScalar(0.5)));\n        return edge;\n    }\n    /**\n     * Rotate an object around an arbitrary axis in world space\n     * @param obj - The THREE.Object3D to rotate\n     * @param axis - The axis in world space\n     * @param radians - The angle in radians\n     */\n    rotateAroundWorldAxis(obj, axis, radians) {\n        let rotWorldMatrix = new THREE.Matrix4();\n        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);\n        rotWorldMatrix.multiply(obj.matrix); // pre-multiply\n        obj.matrix = rotWorldMatrix;\n        obj.rotation.setFromRotationMatrix(obj.matrix);\n    }\n}\n\n\n//# sourceURL=webpack://matviewer/./src/js/viewer.js?");

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** multi ./src/js/entry.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/js/entry.js */\"./src/js/entry.js\");\n\n\n//# sourceURL=webpack://matviewer/multi_./src/js/entry.js?");

/***/ })

/******/ });